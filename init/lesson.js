{"basics":{"Title":"包、变量和函数。","Description":"学习 Go 程序的基本结构。","Pages":[{"Title":"包","Content":"\n  \u003ch2\u003e包\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    每个 Go 程序都是由包构成的。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    程序从 \u003ccode\u003emain\u003c/code\u003e 包开始运行。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    本程序通过导入路径 \u003ccode\u003e\u0026#34;fmt\u0026#34;\u003c/code\u003e 和 \u003ccode\u003e\u0026#34;math/rand\u0026#34;\u003c/code\u003e 来使用这两个包。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    按照约定，包名与导入路径的最后一个元素一致。例如，\u003ccode\u003e\u0026#34;math/rand\u0026#34;\u003c/code\u003e 包中的源码均以 \u003ccode\u003epackage rand\u003c/code\u003e 语句开始。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"packages.go","Content":"package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n)\n\nfunc main() {\n\tfmt.Println(\"My favorite number is\", rand.Intn(10))\n}\n","Hash":"3pUhjlSXGcPdkYyhESbolPagQdc="}]},{"Title":"导入","Content":"\n  \u003ch2\u003e导入\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    此代码用圆括号组合了导入，这是“分组”形式的导入语句。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    当然你也可以编写多个导入语句，例如：\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003eimport \u0026#34;fmt\u0026#34;\nimport \u0026#34;math\u0026#34;\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    不过使用分组导入语句是更好的形式。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"imports.go","Content":"package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc main() {\n\tfmt.Printf(\"Now you have %g problems.\", math.Sqrt(7))\n}\n","Hash":"4OxSW8AnkU+gds2vJ471JCWxt6A="}]},{"Title":"导出名","Content":"\n  \u003ch2\u003e导出名\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    在 Go 中，如果一个名字以大写字母开头，那么它就是已导出的。例如，\u003ccode\u003ePizza\u003c/code\u003e 就是个已导出名，\u003ccode\u003ePi\u003c/code\u003e 也同样，它导出自 \u003ccode\u003emath\u003c/code\u003e 包。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ccode\u003epizza\u003c/code\u003e 和 \u003ccode\u003epi\u003c/code\u003e 并未以大写字母开头，所以它们是未导出的。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    在导入一个包时，你只能引用其中已导出的名字。任何“未导出”的名字在该包外均无法访问。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    执行代码，观察错误输出。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    然后将 \u003ccode\u003emath.pi\u003c/code\u003e 改名为 \u003ccode\u003emath.Pi\u003c/code\u003e 再试着执行一次。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"exported-names.go","Content":"package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc main() {\n\tfmt.Println(math.pi)\n}\n","Hash":"8BpBAuTlXDhXXWKPhaWnx31jlc4="}]},{"Title":"函数","Content":"\n  \u003ch2\u003e函数\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    函数可以没有参数或接受多个参数。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    在本例中，\u003ccode\u003eadd\u003c/code\u003e 接受两个 \u003ccode\u003eint\u003c/code\u003e 类型的参数。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    注意类型在变量名 \u003cb\u003e之后\u003c/b\u003e。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    （参考 \u003ca href=\"http://blog.go-zh.org/gos-declaration-syntax\" target=\"_blank\"\u003e这篇关于 Go 语法声明的文章\u003c/a\u003e了解这种类型声明形式出现的原因。）\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"functions.go","Content":"package main\n\nimport \"fmt\"\n\nfunc add(x int, y int) int {\n\treturn x + y\n}\n\nfunc main() {\n\tfmt.Println(add(42, 13))\n}\n","Hash":"QaLixiSTN/1jtTTP0xgV88EiWbc="}]},{"Title":"函数（续）","Content":"\n  \u003ch2\u003e函数（续）\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    当连续两个或多个函数的已命名形参类型相同时，除最后一个类型以外，其它都可以省略。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    在本例中，\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003ex int, y int\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    被缩写为\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003ex, y int\u003c/pre\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"functions-continued.go","Content":"package main\n\nimport \"fmt\"\n\nfunc add(x, y int) int {\n\treturn x + y\n}\n\nfunc main() {\n\tfmt.Println(add(42, 13))\n}\n","Hash":"qq29LGsGzc3ACpeMJkDSISHbqoM="}]},{"Title":"多值返回","Content":"\n  \u003ch2\u003e多值返回\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    函数可以返回任意数量的返回值。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ccode\u003eswap\u003c/code\u003e 函数返回了两个字符串。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"multiple-results.go","Content":"package main\n\nimport \"fmt\"\n\nfunc swap(x, y string) (string, string) {\n\treturn y, x\n}\n\nfunc main() {\n\ta, b := swap(\"hello\", \"world\")\n\tfmt.Println(a, b)\n}\n","Hash":"VjRC6BmdaRQPFvF3JIg+6vzY0rc="}]},{"Title":"命名返回值","Content":"\n  \u003ch2\u003e命名返回值\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    Go 的返回值可被命名，它们会被视作定义在函数顶部的变量。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    返回值的名称应当具有一定的意义，它可以作为文档使用。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    没有参数的 \u003ccode\u003ereturn\u003c/code\u003e 语句返回已命名的返回值。也就是 \u003ccode\u003e直接\u003c/code\u003e 返回。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    直接返回语句应当仅用在下面这样的短函数中。在长的函数中它们会影响代码的可读性。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"named-results.go","Content":"package main\n\nimport \"fmt\"\n\nfunc split(sum int) (x, y int) {\n\tx = sum * 4 / 9\n\ty = sum - x\n\treturn\n}\n\nfunc main() {\n\tfmt.Println(split(17))\n}\n","Hash":"AX7YGFmJ2woSa5QTgkprkNt7Ezo="}]},{"Title":"变量","Content":"\n  \u003ch2\u003e变量\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    \u003ccode\u003evar\u003c/code\u003e 语句用于声明一个变量列表，跟函数的参数列表一样，类型在最后。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    就像在这个例子中看到的一样，\u003ccode\u003evar\u003c/code\u003e 语句可以出现在包或函数级别。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"variables.go","Content":"package main\n\nimport \"fmt\"\n\nvar c, python, java bool\n\nfunc main() {\n\tvar i int\n\tfmt.Println(i, c, python, java)\n}\n","Hash":"IA/svTzSJDH25Jj1VK/auHbrfx0="}]},{"Title":"变量的初始化","Content":"\n  \u003ch2\u003e变量的初始化\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    变量声明可以包含初始值，每个变量对应一个。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    如果初始化值已存在，则可以省略类型；变量会从初始值中获得类型。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"variables-with-initializers.go","Content":"package main\n\nimport \"fmt\"\n\nvar i, j int = 1, 2\n\nfunc main() {\n\tvar c, python, java = true, false, \"no!\"\n\tfmt.Println(i, j, c, python, java)\n}\n","Hash":"kxySFjAqlylR+dCDsQvw5Ni0k8Q="}]},{"Title":"短变量声明","Content":"\n  \u003ch2\u003e短变量声明\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    在函数中，简洁赋值语句 \u003ccode\u003e:=\u003c/code\u003e 可在类型明确的地方代替 \u003ccode\u003evar\u003c/code\u003e 声明。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    函数外的每个语句都必须以关键字开始（\u003ccode\u003evar\u003c/code\u003e, \u003ccode\u003efunc\u003c/code\u003e 等等），因此 \u003ccode\u003e:=\u003c/code\u003e 结构不能在函数外使用。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"short-variable-declarations.go","Content":"package main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar i, j int = 1, 2\n\tk := 3\n\tc, python, java := true, false, \"no!\"\n\n\tfmt.Println(i, j, k, c, python, java)\n}\n","Hash":"Zz6rkZD1xvZ8Y0U9xTSOJQ3Ec3o="}]},{"Title":"基本类型","Content":"\n  \u003ch2\u003e基本类型\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    Go 的基本类型有\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003ebool\n\nstring\n\nint  int8  int16  int32  int64\nuint uint8 uint16 uint32 uint64 uintptr\n\nbyte // uint8 的别名\n\nrune // int32 的别名\n    // 表示一个 Unicode 码点\n\nfloat32 float64\n\ncomplex64 complex128\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    本例展示了几种类型的变量。\n\n\n    同导入语句一样，变量声明也可以“分组”成一个语法块。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ccode\u003eint\u003c/code\u003e, \u003ccode\u003euint\u003c/code\u003e 和 \u003ccode\u003euintptr\u003c/code\u003e 在 32 位系统上通常为 32 位宽，在 64 位系统上则为 64 位宽。\n\n\n    当你需要一个整数值时应使用 \u003ccode\u003eint\u003c/code\u003e 类型，除非你有特殊的理由使用固定大小或无符号的整数类型。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"basic-types.go","Content":"package main\n\nimport (\n\t\"fmt\"\n\t\"math/cmplx\"\n)\n\nvar (\n\tToBe   bool       = false\n\tMaxInt uint64     = 1\u003c\u003c64 - 1\n\tz      complex128 = cmplx.Sqrt(-5 + 12i)\n)\n\nfunc main() {\n\tfmt.Printf(\"Type: %T Value: %v\\n\", ToBe, ToBe)\n\tfmt.Printf(\"Type: %T Value: %v\\n\", MaxInt, MaxInt)\n\tfmt.Printf(\"Type: %T Value: %v\\n\", z, z)\n}\n","Hash":"uwd31YbyEsiXFNRjmD+EEctimpc="}]},{"Title":"零值","Content":"\n  \u003ch2\u003e零值\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    没有明确初始值的变量声明会被赋予它们的 \u003cb\u003e零值\u003c/b\u003e。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    零值是：\n  \u003c/p\u003e\n  \n\n  \u003cul\u003e\n  \n    \u003cli\u003e数值类型为 \u003ccode\u003e0\u003c/code\u003e，\u003c/li\u003e\n  \n    \u003cli\u003e布尔类型为 \u003ccode\u003efalse\u003c/code\u003e，\u003c/li\u003e\n  \n    \u003cli\u003e字符串为 \u003ccode\u003e\u0026#34;\u0026#34;\u003c/code\u003e（空字符串）。\u003c/li\u003e\n  \n  \u003c/ul\u003e\n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"zero.go","Content":"package main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar i int\n\tvar f float64\n\tvar b bool\n\tvar s string\n\tfmt.Printf(\"%v %v %v %q\\n\", i, f, b, s)\n}\n","Hash":"3oy0IiXxtycOjQCkuWLqLa29xzU="}]},{"Title":"类型转换","Content":"\n  \u003ch2\u003e类型转换\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    表达式 \u003ccode\u003eT(v)\u003c/code\u003e 将值 \u003ccode\u003ev\u003c/code\u003e 转换为类型 \u003ccode\u003eT\u003c/code\u003e。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    一些关于数值的转换：\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003evar i int = 42\nvar f float64 = float64(i)\nvar u uint = uint(f)\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    或者，更加简单的形式：\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003ei := 42\nf := float64(i)\nu := uint(f)\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    与 C 不同的是，Go 在不同类型的项之间赋值时需要显式转换。试着移除例子中 \u003ccode\u003efloat64\u003c/code\u003e 或 \u003ccode\u003euint\u003c/code\u003e 的转换看看会发生什么。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"type-conversions.go","Content":"package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc main() {\n\tvar x, y int = 3, 4\n\tvar f float64 = math.Sqrt(float64(x*x + y*y))\n\tvar z uint = uint(f)\n\tfmt.Println(x, y, z)\n}\n","Hash":"JGbg9tutd+lDvoRTFMaTExwsKAk="}]},{"Title":"类型推导","Content":"\n  \u003ch2\u003e类型推导\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    在声明一个变量而不指定其类型时（即使用不带类型的 \u003ccode\u003e:=\u003c/code\u003e 语法或 \u003ccode\u003evar =\u003c/code\u003e 表达式语法），变量的类型由右值推导得出。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    当右值声明了类型时，新变量的类型与其相同：\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003evar i int\nj := i // j 也是一个 int\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    不过当右边包含未指明类型的数值常量时，新变量的类型就可能是 \u003ccode\u003eint\u003c/code\u003e, \u003ccode\u003efloat64\u003c/code\u003e 或 \u003ccode\u003ecomplex128\u003c/code\u003e 了，这取决于常量的精度：\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003ei := 42           // int\nf := 3.142        // float64\ng := 0.867 \u0026#43; 0.5i // complex128\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    尝试修改示例代码中 \u003ccode\u003ev\u003c/code\u003e 的初始值，并观察它是如何影响类型的。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"type-inference.go","Content":"package main\n\nimport \"fmt\"\n\nfunc main() {\n\tv := 42 // 修改这里！\n\tfmt.Printf(\"v is of type %T\\n\", v)\n}\n","Hash":"13NZzJ5H+DdjI/bxlvMAOfBZVE4="}]},{"Title":"常量","Content":"\n  \u003ch2\u003e常量\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    常量的声明与变量类似，只不过是使用 \u003ccode\u003econst\u003c/code\u003e 关键字。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    常量可以是字符、字符串、布尔值或数值。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    常量不能用 \u003ccode\u003e:=\u003c/code\u003e 语法声明。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"constants.go","Content":"package main\n\nimport \"fmt\"\n\nconst Pi = 3.14\n\nfunc main() {\n\tconst World = \"世界\"\n\tfmt.Println(\"Hello\", World)\n\tfmt.Println(\"Happy\", Pi, \"Day\")\n\n\tconst Truth = true\n\tfmt.Println(\"Go rules?\", Truth)\n}\n","Hash":"/KqzBNsqfHiVdOg92MiKtXMexkU="}]},{"Title":"数值常量","Content":"\n  \u003ch2\u003e数值常量\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    数值常量是高精度的 \u003cb\u003e值\u003c/b\u003e。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    一个未指定类型的常量由上下文来决定其类型。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    再尝试一下输出 \u003ccode\u003eneedInt(Big)\u003c/code\u003e 吧。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    （\u003ccode\u003eint\u003c/code\u003e 类型最大可以存储一个 64 位的整数，有时会更小。）\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    （\u003ccode\u003eint\u003c/code\u003e 可以存放最大64位的整数，根据平台不同有时会更少。）\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"numeric-constants.go","Content":"package main\n\nimport \"fmt\"\n\nconst (\n\t// Create a huge number by shifting a 1 bit left 100 places.\n\t// In other words, the binary number that is 1 followed by 100 zeroes.\n\tBig = 1 \u003c\u003c 100\n\t// Shift it right again 99 places, so we end up with 1\u003c\u003c1, or 2.\n\tSmall = Big \u003e\u003e 99\n)\n\nfunc needInt(x int) int { return x*10 + 1 }\nfunc needFloat(x float64) float64 {\n\treturn x * 0.1\n}\n\nfunc main() {\n\tfmt.Println(needInt(Small))\n\tfmt.Println(needFloat(Small))\n\tfmt.Println(needFloat(Big))\n}\n","Hash":"mpa1CTTD2KsjpKwVpbHo9Jz/ujM="}]},{"Title":"恭喜！","Content":"\n  \u003ch2\u003e恭喜！\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    你已经完成了本课程！\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    你可以返回\u003ca href=\"/list\" target=\"_self\"\u003e模块\u003c/a\u003e列表看看接下来要学什么，或者继续\u003ca href=\"javascript:click(\u0026#39;.next-page\u0026#39;)\" target=\"_self\"\u003e后面的课程\u003c/a\u003e。\n  \u003c/p\u003e\n  \n\n","Files":[]}]}
,"flowcontrol":{"Title":"流程控制语句：for、if、else、switch 和 defer","Description":"学习如何使用条件、循环、分支和推迟语句来控制代码的流程。","Pages":[{"Title":"for","Content":"\n  \u003ch2\u003efor\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    Go 只有一种循环结构：\u003ccode\u003efor\u003c/code\u003e 循环。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    基本的 \u003ccode\u003efor\u003c/code\u003e 循环由三部分组成，它们用分号隔开：\n  \u003c/p\u003e\n  \n\n  \u003cul\u003e\n  \n    \u003cli\u003e初始化语句：在第一次迭代前执行\u003c/li\u003e\n  \n    \u003cli\u003e条件表达式：在每次迭代前求值\u003c/li\u003e\n  \n    \u003cli\u003e后置语句：在每次迭代的结尾执行\u003c/li\u003e\n  \n  \u003c/ul\u003e\n\n  \n  \u003cp\u003e\n    初始化语句通常为一句短变量声明，该变量声明仅在 \u003ccode\u003efor\u003c/code\u003e 语句的作用域中可见。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    一旦条件表达式的布尔值为 \u003ccode\u003efalse\u003c/code\u003e，循环迭代就会终止。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003cb\u003e注意\u003c/b\u003e：和 C、Java、JavaScript 之类的语言不同，Go 的 for 语句后面没有小括号，大括号 \u003ccode\u003e{ }\u003c/code\u003e 则是必须的。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"for.go","Content":"package main\n\nimport \"fmt\"\n\nfunc main() {\n\tsum := 0\n\tfor i := 0; i \u003c 10; i++ {\n\t\tsum += i\n\t}\n\tfmt.Println(sum)\n}\n","Hash":"xJO/6+FEIQikuVbnofxw9o7g3Ig="}]},{"Title":"for（续）","Content":"\n  \u003ch2\u003efor（续）\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    初始化语句和后置语句是可选的。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"for-continued.go","Content":"package main\n\nimport \"fmt\"\n\nfunc main() {\n\tsum := 1\n\tfor ; sum \u003c 1000; {\n\t\tsum += sum\n\t}\n\tfmt.Println(sum)\n}\n","Hash":"1SQ3UcrOPXhbZIL80CcWqOUSGP4="}]},{"Title":"for 是 Go 中的 “while”","Content":"\n  \u003ch2\u003efor 是 Go 中的 “while”\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    此时你可以去掉分号，因为 C 的 \u003ccode\u003ewhile\u003c/code\u003e 在 Go 中叫做 \u003ccode\u003efor\u003c/code\u003e。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"for-is-gos-while.go","Content":"package main\n\nimport \"fmt\"\n\nfunc main() {\n\tsum := 1\n\tfor sum \u003c 1000 {\n\t\tsum += sum\n\t}\n\tfmt.Println(sum)\n}\n","Hash":"0C6Q8vy+sOTo5FmeCSn0gOHKfis="}]},{"Title":"无限循环","Content":"\n  \u003ch2\u003e无限循环\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    如果省略循环条件，该循环就不会结束，因此无限循环可以写得很紧凑。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"forever.go","Content":"package main\n\nfunc main() {\n\tfor {\n\t}\n}\n","Hash":"LGPmerQM9dL5ipTYobVqMxgS2zc="}]},{"Title":"if","Content":"\n  \u003ch2\u003eif\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    Go 的 \u003ccode\u003eif\u003c/code\u003e 语句与 \u003ccode\u003efor\u003c/code\u003e 循环类似，表达式外无需小括号 \u003ccode\u003e( )\u003c/code\u003e ，而大括号 \u003ccode\u003e{ }\u003c/code\u003e 则是必须的。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"if.go","Content":"package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc sqrt(x float64) string {\n\tif x \u003c 0 {\n\t\treturn sqrt(-x) + \"i\"\n\t}\n\treturn fmt.Sprint(math.Sqrt(x))\n}\n\nfunc main() {\n\tfmt.Println(sqrt(2), sqrt(-4))\n}\n","Hash":"r6fhyVTMogkJiLiZwAdhwGl+kZM="}]},{"Title":"if 的简短语句","Content":"\n  \u003ch2\u003eif 的简短语句\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    同 \u003ccode\u003efor\u003c/code\u003e 一样， \u003ccode\u003eif\u003c/code\u003e 语句可以在条件表达式前执行一个简单的语句。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    该语句声明的变量作用域仅在 \u003ccode\u003eif\u003c/code\u003e 之内。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    （在最后的 \u003ccode\u003ereturn\u003c/code\u003e 语句处使用 \u003ccode\u003ev\u003c/code\u003e 看看。）\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"if-with-a-short-statement.go","Content":"package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc pow(x, n, lim float64) float64 {\n\tif v := math.Pow(x, n); v \u003c lim {\n\t\treturn v\n\t}\n\treturn lim\n}\n\nfunc main() {\n\tfmt.Println(\n\t\tpow(3, 2, 10),\n\t\tpow(3, 3, 20),\n\t)\n}\n","Hash":"Qdj1mMXhmi0bxex0sdU6BzhPM+g="}]},{"Title":"if 和 else","Content":"\n  \u003ch2\u003eif 和 else\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    在 \u003ccode\u003eif\u003c/code\u003e 的简短语句中声明的变量同样可以在任何对应的 \u003ccode\u003eelse\u003c/code\u003e 块中使用。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    （在 \u003ccode\u003emain\u003c/code\u003e 的 \u003ccode\u003efmt.Println\u003c/code\u003e 调用开始前，两次对 \u003ccode\u003epow\u003c/code\u003e 的调用均已执行并返回。）\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"if-and-else.go","Content":"package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc pow(x, n, lim float64) float64 {\n\tif v := math.Pow(x, n); v \u003c lim {\n\t\treturn v\n\t} else {\n\t\tfmt.Printf(\"%g \u003e= %g\\n\", v, lim)\n\t}\n\t// 这里开始就不能使用 v 了\n\treturn lim\n}\n\nfunc main() {\n\tfmt.Println(\n\t\tpow(3, 2, 10),\n\t\tpow(3, 3, 20),\n\t)\n}\n","Hash":"TZHP73hsce5JheSbLeBLRxtBbG8="}]},{"Title":"练习：循环与函数","Content":"\n  \u003ch2\u003e练习：循环与函数\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    为了练习函数与循环，我们来实现一个平方根函数：用牛顿法实现平方根函数。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    计算机通常使用循环来计算 x 的平方根。从某个猜测的值 z 开始，我们可以根据 z² 与 x 的近似度来调整 z，产生一个更好的猜测：\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003ez -= (z*z - x) / (2*z)\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    重复调整的过程，猜测的结果会越来越精确，得到的答案也会尽可能接近实际的平方根。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    在提供的 \u003ccode\u003efunc Sqrt\u003c/code\u003e 中实现它。无论输入是什么，对 z 的一个恰当的猜测为 1。\n\n\n    要开始，请重复计算 10 次并随之打印每次的 z 值。观察对于不同的值 x（1、2、3 ...），\n\n\n    你得到的答案是如何逼近结果的，猜测提升的速度有多快。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    提示：用类型转换或浮点数语法来声明并初始化一个浮点数值：\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003ez := 1.0\nz := float64(1)\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    然后，修改循环条件，使得当值停止改变（或改变非常小）的时候退出循环。观察迭代次数大于还是小于 10。\n\n\n    尝试改变 z 的初始猜测，如 x 或 x/2。你的函数结果与标准库中的 \u003ca href=\"https://go-zh.org/pkg/math/#Sqrt\" target=\"_blank\"\u003emath.Sqrt\u003c/a\u003e 接近吗？\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    （注：如果你对该算法的细节感兴趣，上面的 z² − x 是 z² 到它所要到达的值（即 x）的距离，除以的 2z 为 z² 的导数，我们通过 z² 的变化速度来改变 z 的调整量。这种通用方法叫做\u003ca href=\"https://zh.wikipedia.org/wiki/%E7%89%9B%E9%A1%BF%E6%B3%95\" target=\"_blank\"\u003e牛顿法\u003c/a\u003e。它对很多函数，特别是平方根而言非常有效。）\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"exercise-loops-and-functions.go","Content":"package main\n\nimport (\n\t\"fmt\"\n)\n\nfunc Sqrt(x float64) float64 {\n}\n\nfunc main() {\n\tfmt.Println(Sqrt(2))\n}\n","Hash":"gtNrJKxe1FGotKs4BtY3aDHG9hM="}]},{"Title":"switch","Content":"\n  \u003ch2\u003eswitch\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    \u003ccode\u003eswitch\u003c/code\u003e 是编写一连串 \u003ccode\u003eif - else\u003c/code\u003e 语句的简便方法。它运行第一个值等于条件表达式的 case 语句。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    Go 的 switch 语句类似于 C、C++、Java、JavaScript 和 PHP 中的，不过 Go 只运行选定的 case，而非之后所有的 case。\n\n\n    实际上，Go 自动提供了在这些语言中每个 case 后面所需的 \u003ccode\u003ebreak\u003c/code\u003e 语句。\n\n\n    除非以 \u003ccode\u003efallthrough\u003c/code\u003e 语句结束，否则分支会自动终止。\n\n\n    Go 的另一点重要的不同在于 switch 的 case 无需为常量，且取值不必为整数。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"switch.go","Content":"package main\n\nimport (\n\t\"fmt\"\n\t\"runtime\"\n)\n\nfunc main() {\n\tfmt.Print(\"Go runs on \")\n\tswitch os := runtime.GOOS; os {\n\tcase \"darwin\":\n\t\tfmt.Println(\"OS X.\")\n\tcase \"linux\":\n\t\tfmt.Println(\"Linux.\")\n\tdefault:\n\t\t// freebsd, openbsd,\n\t\t// plan9, windows...\n\t\tfmt.Printf(\"%s.\", os)\n\t}\n}\n","Hash":"hfkCEcj/AvLuHnC1VVHQCo6pqfU="}]},{"Title":"switch 的求值顺序","Content":"\n  \u003ch2\u003eswitch 的求值顺序\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    switch 的 case 语句从上到下顺次执行，直到匹配成功时停止。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    （例如，\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003eswitch i {\ncase 0:\ncase f():\n}\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    在 \u003ccode\u003ei==0\u003c/code\u003e 时 \u003ccode\u003ef\u003c/code\u003e 不会被调用。）\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"switch-evaluation-order.go","Content":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tfmt.Println(\"When's Saturday?\")\n\ttoday := time.Now().Weekday()\n\tswitch time.Saturday {\n\tcase today + 0:\n\t\tfmt.Println(\"Today.\")\n\tcase today + 1:\n\t\tfmt.Println(\"Tomorrow.\")\n\tcase today + 2:\n\t\tfmt.Println(\"In two days.\")\n\tdefault:\n\t\tfmt.Println(\"Too far away.\")\n\t}\n}\n","Hash":"Hevv3n4U/ccdvgrd6ETU4Y2vgkg="}]},{"Title":"没有条件的 switch","Content":"\n  \u003ch2\u003e没有条件的 switch\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    没有条件的 switch 同 \u003ccode\u003eswitch true\u003c/code\u003e 一样。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    这种形式能将一长串 if-then-else 写得更加清晰。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"switch-with-no-condition.go","Content":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tt := time.Now()\n\tswitch {\n\tcase t.Hour() \u003c 12:\n\t\tfmt.Println(\"Good morning!\")\n\tcase t.Hour() \u003c 17:\n\t\tfmt.Println(\"Good afternoon.\")\n\tdefault:\n\t\tfmt.Println(\"Good evening.\")\n\t}\n}\n","Hash":"03rL/Cr+GvYFECOFbBJv5IX4Q9Y="}]},{"Title":"defer","Content":"\n  \u003ch2\u003edefer\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    defer 语句会将函数推迟到外层函数返回之后执行。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"defer.go","Content":"package main\n\nimport \"fmt\"\n\nfunc main() {\n\tdefer fmt.Println(\"world\")\n\n\tfmt.Println(\"hello\")\n}\n","Hash":"2Z9b5KH9i2dp2TZu26N0xR/Af6Q="}]},{"Title":"defer 栈","Content":"\n  \u003ch2\u003edefer 栈\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    推迟的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照后进先出的顺序调用。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    更多关于 defer 语句的信息，请阅读\u003ca href=\"http://blog.go-zh.org/defer-panic-and-recover\" target=\"_blank\"\u003e此博文\u003c/a\u003e。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"defer-multi.go","Content":"package main\n\nimport \"fmt\"\n\nfunc main() {\n\tfmt.Println(\"counting\")\n\n\tfor i := 0; i \u003c 10; i++ {\n\t\tdefer fmt.Println(i)\n\t}\n\n\tfmt.Println(\"done\")\n}\n","Hash":"BFzzho+ksu2wU+yyZOcnJ5z3kQg="}]},{"Title":"恭喜！","Content":"\n  \u003ch2\u003e恭喜！\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    你已经完成了本课程！\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    你可以返回\u003ca href=\"/list\" target=\"_self\"\u003e模块\u003c/a\u003e列表看看接下来学习什么，也可以继续\u003ca href=\"javascript:click(\u0026#39;.next-page\u0026#39;)\" target=\"_self\"\u003e后面的课程\u003c/a\u003e。\n  \u003c/p\u003e\n  \n\n","Files":[]}]}
,"concurrency":{"Title":"并发","Description":"Go 将并发结构作为核心语言的一部分提供。本节课程通过一些示例介绍并展示了它们的用法。","Pages":[{"Title":"Go 程","Content":"\n  \u003ch2\u003eGo 程\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    Go 程（goroutine）是由 Go 运行时管理的轻量级线程。\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003ego f(x, y, z)\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    会启动一个新的 Go 程并执行\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003ef(x, y, z)\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ccode\u003ef\u003c/code\u003e, \u003ccode\u003ex\u003c/code\u003e, \u003ccode\u003ey\u003c/code\u003e 和 \u003ccode\u003ez\u003c/code\u003e 的求值发生在当前的 Go 程中，而 \u003ccode\u003ef\u003c/code\u003e 的执行发生在新的 Go 程中。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    Go 程在相同的地址空间中运行，因此在访问共享的内存时必须进行同步。\u003ca href=\"https://go-zh.org/pkg/sync/\" target=\"_blank\"\u003e\u003ccode\u003esync\u003c/code\u003e\u003c/a\u003e 包提供了这种能力，不过在 Go 中并不经常用到，因为还有其它的办法（见下一页）。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"goroutines.go","Content":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc say(s string) {\n\tfor i := 0; i \u003c 5; i++ {\n\t\ttime.Sleep(100 * time.Millisecond)\n\t\tfmt.Println(s)\n\t}\n}\n\nfunc main() {\n\tgo say(\"world\")\n\tsay(\"hello\")\n}\n","Hash":"V0QWmtbyKtRACHLggPFEhVfjtHk="}]},{"Title":"信道","Content":"\n  \u003ch2\u003e信道\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    信道是带有类型的管道，你可以通过它用信道操作符 \u003ccode\u003e\u0026lt;-\u003c/code\u003e 来发送或者接收值。\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003ech \u0026lt;- v    // 将 v 发送至信道 ch。\nv := \u0026lt;-ch  // 从 ch 接收值并赋予 v。\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    （“箭头”就是数据流的方向。）\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    和映射与切片一样，信道在使用前必须创建：\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003ech := make(chan int)\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    默认情况下，发送和接收操作在另一端准备好之前都会阻塞。这使得 Go 程可以在没有显式的锁或竞态变量的情况下进行同步。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    以下示例对切片中的数进行求和，将任务分配给两个 Go 程。一旦两个 Go 程完成了它们的计算，它就能算出最终的结果。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"channels.go","Content":"package main\n\nimport \"fmt\"\n\nfunc sum(s []int, c chan int) {\n\tsum := 0\n\tfor _, v := range s {\n\t\tsum += v\n\t}\n\tc \u003c- sum // 将和送入 c\n}\n\nfunc main() {\n\ts := []int{7, 2, 8, -9, 4, 0}\n\n\tc := make(chan int)\n\tgo sum(s[:len(s)/2], c)\n\tgo sum(s[len(s)/2:], c)\n\tx, y := \u003c-c, \u003c-c // 从 c 中接收\n\n\tfmt.Println(x, y, x+y)\n}\n","Hash":"50Y6kVnrCfYlaVzPBl707yO8p1c="}]},{"Title":"带缓冲的信道","Content":"\n  \u003ch2\u003e带缓冲的信道\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    信道可以是 \u003ci\u003e带缓冲的\u003c/i\u003e。将缓冲长度作为第二个参数提供给 \u003ccode\u003emake\u003c/code\u003e 来初始化一个带缓冲的信道：\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003ech := make(chan int, 100)\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    仅当信道的缓冲区填满后，向其发送数据时才会阻塞。当缓冲区为空时，接受方会阻塞。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    修改示例填满缓冲区，然后看看会发生什么。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"buffered-channels.go","Content":"package main\n\nimport \"fmt\"\n\nfunc main() {\n\tch := make(chan int, 2)\n\tch \u003c- 1\n\tch \u003c- 2\n\tfmt.Println(\u003c-ch)\n\tfmt.Println(\u003c-ch)\n}\n","Hash":"HNpu4gbNWpP4WP/6znFerbBix/U="}]},{"Title":"range 和 close","Content":"\n  \u003ch2\u003erange 和 close\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    发送者可通过 \u003ccode\u003eclose\u003c/code\u003e 关闭一个信道来表示没有需要发送的值了。接收者可以通过为接收表达式分配第二个参数来测试信道是否被关闭：若没有值可以接收且信道已被关闭，那么在执行完\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003ev, ok := \u0026lt;-ch\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    之后 \u003ccode\u003eok\u003c/code\u003e 会被设置为 \u003ccode\u003efalse\u003c/code\u003e。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    循环 \u003ccode\u003efor i := range c\u003c/code\u003e 会不断从信道接收值，直到它被关闭。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003cb\u003e注意：\u003c/b\u003e 只有发送者才能关闭信道，而接收者不能。向一个已经关闭的信道发送数据会引发程序恐慌（panic）。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003cb\u003e还要注意：\u003c/b\u003e 信道与文件不同，通常情况下无需关闭它们。只有在必须告诉接收者不再有值需要发送的时候才有必要关闭，例如终止一个 \u003ccode\u003erange\u003c/code\u003e 循环。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"range-and-close.go","Content":"package main\n\nimport (\n\t\"fmt\"\n)\n\nfunc fibonacci(n int, c chan int) {\n\tx, y := 0, 1\n\tfor i := 0; i \u003c n; i++ {\n\t\tc \u003c- x\n\t\tx, y = y, x+y\n\t}\n\tclose(c)\n}\n\nfunc main() {\n\tc := make(chan int, 10)\n\tgo fibonacci(cap(c), c)\n\tfor i := range c {\n\t\tfmt.Println(i)\n\t}\n}\n","Hash":"4FtqldYWvLh1vO6HNWvr/RcwgBk="}]},{"Title":"select 语句","Content":"\n  \u003ch2\u003eselect 语句\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    \u003ccode\u003eselect\u003c/code\u003e 语句使一个 Go 程可以等待多个通信操作。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ccode\u003eselect\u003c/code\u003e 会阻塞到某个分支可以继续执行为止，这时就会执行该分支。当多个分支都准备好时会随机选择一个执行。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"select.go","Content":"package main\n\nimport \"fmt\"\n\nfunc fibonacci(c, quit chan int) {\n\tx, y := 0, 1\n\tfor {\n\t\tselect {\n\t\tcase c \u003c- x:\n\t\t\tx, y = y, x+y\n\t\tcase \u003c-quit:\n\t\t\tfmt.Println(\"quit\")\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc main() {\n\tc := make(chan int)\n\tquit := make(chan int)\n\tgo func() {\n\t\tfor i := 0; i \u003c 10; i++ {\n\t\t\tfmt.Println(\u003c-c)\n\t\t}\n\t\tquit \u003c- 0\n\t}()\n\tfibonacci(c, quit)\n}\n","Hash":"fsgO6l9yS4Jib1uMTvh+1giFpfg="}]},{"Title":"默认选择","Content":"\n  \u003ch2\u003e默认选择\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    当 \u003ccode\u003eselect\u003c/code\u003e 中的其它分支都没有准备好时，\u003ccode\u003edefault\u003c/code\u003e 分支就会执行。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    为了在尝试发送或者接收时不发生阻塞，可使用 \u003ccode\u003edefault\u003c/code\u003e 分支：\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003eselect {\ncase i := \u0026lt;-c:\n    // 使用 i\ndefault:\n    // 从 c 中接收会阻塞时执行\n}\u003c/pre\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"default-selection.go","Content":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\ttick := time.Tick(100 * time.Millisecond)\n\tboom := time.After(500 * time.Millisecond)\n\tfor {\n\t\tselect {\n\t\tcase \u003c-tick:\n\t\t\tfmt.Println(\"tick.\")\n\t\tcase \u003c-boom:\n\t\t\tfmt.Println(\"BOOM!\")\n\t\t\treturn\n\t\tdefault:\n\t\t\tfmt.Println(\"    .\")\n\t\t\ttime.Sleep(50 * time.Millisecond)\n\t\t}\n\t}\n}\n","Hash":"13nYcML2cEMSMR4KdD858o88aTY="}]},{"Title":"练习：等价二叉查找树","Content":"\n  \u003ch2\u003e练习：等价二叉查找树\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    不同二叉树的叶节点上可以保存相同的值序列。例如，以下两个二叉树都保存了序列 \u003ccode\u003e1，1，2，3，5，8，13\u003c/code\u003e。\n  \u003c/p\u003e\n  \n\n  \u003cimg src=\"/content/img/tree.png\"\u003e\n\n  \n  \u003cp\u003e\n    在大多数语言中，检查两个二叉树是否保存了相同序列的函数都相当复杂。\n\n\n    我们将使用 Go 的并发和信道来编写一个简单的解法。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    本例使用了 \u003ccode\u003etree\u003c/code\u003e 包，它定义了类型：\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003etype Tree struct {\n    Left  *Tree\n    Value int\n    Right *Tree\n}\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    点击\u003ca href=\"javascript:click(\u0026#39;.next-page\u0026#39;)\" target=\"_self\"\u003e下一页\u003c/a\u003e继续。\n  \u003c/p\u003e\n  \n\n","Files":[]},{"Title":"练习：等价二叉查找树","Content":"\n  \u003ch2\u003e练习：等价二叉查找树\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    \u003cb\u003e1.\u003c/b\u003e 实现 \u003ccode\u003eWalk\u003c/code\u003e 函数。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003cb\u003e2.\u003c/b\u003e 测试 \u003ccode\u003eWalk\u003c/code\u003e 函数。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    函数 \u003ccode\u003etree.New(k)\u003c/code\u003e 用于构造一个随机结构的已排序二叉查找树，它保存了值 \u003ccode\u003ek\u003c/code\u003e, \u003ccode\u003e2k\u003c/code\u003e, \u003ccode\u003e3k\u003c/code\u003e, ..., \u003ccode\u003e10k\u003c/code\u003e。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    创建一个新的信道 \u003ccode\u003ech\u003c/code\u003e 并且对其进行步进：\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003ego Walk(tree.New(1), ch)\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    然后从信道中读取并打印 10 个值。应当是数字 \u003ccode\u003e1, 2, 3, ..., 10\u003c/code\u003e。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003cb\u003e3.\u003c/b\u003e 用 \u003ccode\u003eWalk\u003c/code\u003e 实现 \u003ccode\u003eSame\u003c/code\u003e 函数来检测 \u003ccode\u003et1\u003c/code\u003e 和 \u003ccode\u003et2\u003c/code\u003e 是否存储了相同的值。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003cb\u003e4.\u003c/b\u003e 测试 \u003ccode\u003eSame\u003c/code\u003e 函数。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ccode\u003eSame(tree.New(1), tree.New(1))\u003c/code\u003e 应当返回 \u003ccode\u003etrue\u003c/code\u003e，而 \u003ccode\u003eSame(tree.New(1), tree.New(2))\u003c/code\u003e 应当返回 \u003ccode\u003efalse\u003c/code\u003e。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ccode\u003eTree\u003c/code\u003e 的文档可在\u003ca href=\"https://godoc.org/golang.org/x/tour/tree#Tree\" target=\"_blank\"\u003e这里\u003c/a\u003e找到。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"exercise-equivalent-binary-trees.go","Content":"package main\n\nimport \"golang.org/x/tour/tree\"\n\n// Walk 步进 tree t 将所有的值从 tree 发送到 channel ch。\nfunc Walk(t *tree.Tree, ch chan int)\n\n// Same 检测树 t1 和 t2 是否含有相同的值。\nfunc Same(t1, t2 *tree.Tree) bool\n\nfunc main() {\n}\n","Hash":"2EeFqh5OaryMV+/l+1ncF2rUiJM="}]},{"Title":"sync.Mutex","Content":"\n  \u003ch2\u003esync.Mutex\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    我们已经看到信道非常适合在各个 Go 程间进行通信。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    但是如果我们并不需要通信呢？比如说，若我们只是想保证每次只有一个 Go 程能够访问一个共享的变量，从而避免冲突？\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    这里涉及的概念叫做 \u003ci\u003e互斥（mutual exclusion）\u003c/i\u003e ，我们通常使用 \u003ci\u003e互斥锁（Mutex）\u003c/i\u003e 这一数据结构来提供这种机制。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    Go 标准库中提供了 \u003ca href=\"https://go-zh.org/pkg/sync/#Mutex\" target=\"_blank\"\u003e\u003ccode\u003esync.Mutex\u003c/code\u003e\u003c/a\u003e 互斥锁类型及其两个方法：\n  \u003c/p\u003e\n  \n\n  \u003cul\u003e\n  \n    \u003cli\u003e\u003ccode\u003eLock\u003c/code\u003e\u003c/li\u003e\n  \n    \u003cli\u003e\u003ccode\u003eUnlock\u003c/code\u003e\u003c/li\u003e\n  \n  \u003c/ul\u003e\n\n  \n  \u003cp\u003e\n    我们可以通过在代码前调用 \u003ccode\u003eLock\u003c/code\u003e 方法，在代码后调用 \u003ccode\u003eUnlock\u003c/code\u003e 方法来保证一段代码的互斥执行。参见 \u003ccode\u003eInc\u003c/code\u003e 方法。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    我们也可以用 \u003ccode\u003edefer\u003c/code\u003e 语句来保证互斥锁一定会被解锁。参见 \u003ccode\u003eValue\u003c/code\u003e 方法。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"mutex-counter.go","Content":"package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\n// SafeCounter 的并发使用是安全的。\ntype SafeCounter struct {\n\tv   map[string]int\n\tmux sync.Mutex\n}\n\n// Inc 增加给定 key 的计数器的值。\nfunc (c *SafeCounter) Inc(key string) {\n\tc.mux.Lock()\n\t// Lock 之后同一时刻只有一个 goroutine 能访问 c.v\n\tc.v[key]++\n\tc.mux.Unlock()\n}\n\n// Value 返回给定 key 的计数器的当前值。\nfunc (c *SafeCounter) Value(key string) int {\n\tc.mux.Lock()\n\t// Lock 之后同一时刻只有一个 goroutine 能访问 c.v\n\tdefer c.mux.Unlock()\n\treturn c.v[key]\n}\n\nfunc main() {\n\tc := SafeCounter{v: make(map[string]int)}\n\tfor i := 0; i \u003c 1000; i++ {\n\t\tgo c.Inc(\"somekey\")\n\t}\n\n\ttime.Sleep(time.Second)\n\tfmt.Println(c.Value(\"somekey\"))\n}\n","Hash":"mUDh9yX7Y9QwDWswzh5WEb2o2Qw="}]},{"Title":"练习：Web 爬虫","Content":"\n  \u003ch2\u003e练习：Web 爬虫\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    在这个练习中，我们将会使用 Go 的并发特性来并行化一个 Web 爬虫。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    修改 \u003ccode\u003eCrawl\u003c/code\u003e 函数来并行地抓取 URL，并且保证不重复。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ci\u003e提示\u003c/i\u003e：你可以用一个 map 来缓存已经获取的 URL，但是要注意 map 本身并不是并发安全的！\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"exercise-web-crawler.go","Content":"package main\n\nimport (\n\t\"fmt\"\n)\n\ntype Fetcher interface {\n\t// Fetch 返回 URL 的 body 内容，并且将在这个页面上找到的 URL 放到一个 slice 中。\n\tFetch(url string) (body string, urls []string, err error)\n}\n\n// Crawl 使用 fetcher 从某个 URL 开始递归的爬取页面，直到达到最大深度。\nfunc Crawl(url string, depth int, fetcher Fetcher) {\n\t// TODO: 并行的抓取 URL。\n\t// TODO: 不重复抓取页面。\n        // 下面并没有实现上面两种情况：\n\tif depth \u003c= 0 {\n\t\treturn\n\t}\n\tbody, urls, err := fetcher.Fetch(url)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tfmt.Printf(\"found: %s %q\\n\", url, body)\n\tfor _, u := range urls {\n\t\tCrawl(u, depth-1, fetcher)\n\t}\n\treturn\n}\n\nfunc main() {\n\tCrawl(\"https://golang.org/\", 4, fetcher)\n}\n\n// fakeFetcher 是返回若干结果的 Fetcher。\ntype fakeFetcher map[string]*fakeResult\n\ntype fakeResult struct {\n\tbody string\n\turls []string\n}\n\nfunc (f fakeFetcher) Fetch(url string) (string, []string, error) {\n\tif res, ok := f[url]; ok {\n\t\treturn res.body, res.urls, nil\n\t}\n\treturn \"\", nil, fmt.Errorf(\"not found: %s\", url)\n}\n\n// fetcher 是填充后的 fakeFetcher。\nvar fetcher = fakeFetcher{\n\t\"https://golang.org/\": \u0026fakeResult{\n\t\t\"The Go Programming Language\",\n\t\t[]string{\n\t\t\t\"https://golang.org/pkg/\",\n\t\t\t\"https://golang.org/cmd/\",\n\t\t},\n\t},\n\t\"https://golang.org/pkg/\": \u0026fakeResult{\n\t\t\"Packages\",\n\t\t[]string{\n\t\t\t\"https://golang.org/\",\n\t\t\t\"https://golang.org/cmd/\",\n\t\t\t\"https://golang.org/pkg/fmt/\",\n\t\t\t\"https://golang.org/pkg/os/\",\n\t\t},\n\t},\n\t\"https://golang.org/pkg/fmt/\": \u0026fakeResult{\n\t\t\"Package fmt\",\n\t\t[]string{\n\t\t\t\"https://golang.org/\",\n\t\t\t\"https://golang.org/pkg/\",\n\t\t},\n\t},\n\t\"https://golang.org/pkg/os/\": \u0026fakeResult{\n\t\t\"Package os\",\n\t\t[]string{\n\t\t\t\"https://golang.org/\",\n\t\t\t\"https://golang.org/pkg/\",\n\t\t},\n\t},\n}\n","Hash":"Of3JUQ4xPsTjj4Nhu+cFPWzrNHA="}]},{"Title":"接下来去哪？","Content":"\n  \u003ch2\u003e接下来去哪？\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    Go\n\n\n    \u003ca href=\"https://go-zh.org/doc/\" target=\"_blank\"\u003e文档\u003c/a\u003e是一个极好的\n\n\n    开始。\n\n\n    它包含了参考、指南、视频等等更多资料。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    了解如何组织 Go 代码并在其上工作，参阅\u003ca href=\"https://www.youtube.com/watch?v=XCsL89YtqCs\" target=\"_blank\"\u003e此视频\u003c/a\u003e，或者阅读\u003ca href=\"https://go-zh.org/doc/code.html\" target=\"_blank\"\u003e如何编写 Go 代码\u003c/a\u003e。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    如果你需要标准库方面的帮助，请参考\u003ca href=\"https://go-zh.org/pkg/\" target=\"_blank\"\u003e包手册\u003c/a\u003e。如果是语言本身的帮助，阅读\u003ca href=\"https://go-zh.org/ref/spec\" target=\"_blank\"\u003e语言规范\u003c/a\u003e是件令人愉快的事情。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    进一步探索 Go 的并发模型，参阅 \u003ca href=\"https://www.youtube.com/watch?v=f6kdp27TYZs\" target=\"_blank\"\u003eGo 并发模型\u003c/a\u003e(\u003ca href=\"https://talks.go-zh.org/2012/concurrency.slide\" target=\"_blank\"\u003e幻灯片\u003c/a\u003e)以及\u003ca href=\"https://www.youtube.com/watch?v=QDDwwePbDtw\" target=\"_blank\"\u003e深入 Go 并发模型\u003c/a\u003e(\u003ca href=\"https://talks.go-zh.org/2013/advconc.slide\" target=\"_blank\"\u003e幻灯片\u003c/a\u003e)并阅读\u003ca href=\"https://go-zh.org/doc/codewalk/sharemem/\" target=\"_blank\"\u003e通过通信共享内存\u003c/a\u003e的代码之旅。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    想要开始编写 Web 应用，请参阅\u003ca href=\"https://vimeo.com/53221558\" target=\"_blank\"\u003e一个简单的编程环境\u003c/a\u003e(\u003ca href=\"https://talks.go-zh.org/2012/simple.slide\" target=\"_blank\"\u003e幻灯片\u003c/a\u003e)并阅读\u003ca href=\"https://go-zh.org/doc/articles/wiki/\" target=\"_blank\"\u003e编写 Web 应用\u003c/a\u003e的指南。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ca href=\"https://go-zh.org/doc/codewalk/functions/\" target=\"_blank\"\u003e函数：Go 中的一等公民\u003c/a\u003e展示了有趣的函数类型。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ca href=\"https://blog.go-zh.org/\" target=\"_blank\"\u003eGo 博客\u003c/a\u003e有着众多关于 Go 的文章和信息。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ca href=\"https://www.mikespook.com/tag/golang/\" target=\"_blank\"\u003emikespook 的博客\u003c/a\u003e中有大量中文的关于 Go 的文章和翻译。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    开源电子书 \u003ca href=\"https://github.com/astaxie/build-web-application-with-golang\" target=\"_blank\"\u003eGo Web 编程\u003c/a\u003e和 \u003ca href=\"https://github.com/Unknwon/the-way-to-go_ZH_CN\" target=\"_blank\"\u003eGo 入门指南\u003c/a\u003e能够帮助你更加深入的了解和学习 Go 语言。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    访问 \u003ca href=\"https://go-zh.org\" target=\"_blank\"\u003ego-zh.org\u003c/a\u003e 了解更多内容。\n  \u003c/p\u003e\n  \n\n","Files":[]}]}
,"moretypes":{"Title":"更多类型：struct、slice 和 映射。","Description":"学习如何基于现有类型定义新的类型：本节课涵盖了结构体、数组、切片和映射。","Pages":[{"Title":"指针","Content":"\n  \u003ch2\u003e指针\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    Go 拥有指针。指针保存了值的内存地址。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    类型 \u003ccode\u003e*T\u003c/code\u003e 是指向 \u003ccode\u003eT\u003c/code\u003e 类型值的指针。其零值为 \u003ccode\u003enil\u003c/code\u003e。\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003evar p *int\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ccode\u003e\u0026amp;\u003c/code\u003e 操作符会生成一个指向其操作数的指针。\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003ei := 42\np = \u0026amp;i\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ccode\u003e*\u003c/code\u003e 操作符表示指针指向的底层值。\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003efmt.Println(*p) // 通过指针 p 读取 i\n*p = 21         // 通过指针 p 设置 i\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    这也就是通常所说的“间接引用”或“重定向”。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    与 C 不同，Go 没有指针运算。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"pointers.go","Content":"package main\n\nimport \"fmt\"\n\nfunc main() {\n\ti, j := 42, 2701\n\n\tp := \u0026i         // point to i\n\tfmt.Println(*p) // read i through the pointer\n\t*p = 21         // set i through the pointer\n\tfmt.Println(i)  // see the new value of i\n\n\tp = \u0026j         // point to j\n\t*p = *p / 37   // divide j through the pointer\n\tfmt.Println(j) // see the new value of j\n}\n","Hash":"i+Ht96dGPTEcg2FJF7q5RseXBDI="}]},{"Title":"结构体","Content":"\n  \u003ch2\u003e结构体\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    一个结构体（\u003ccode\u003estruct\u003c/code\u003e）就是一个字段的集合。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"structs.go","Content":"package main\n\nimport \"fmt\"\n\ntype Vertex struct {\n\tX int\n\tY int\n}\n\nfunc main() {\n\tfmt.Println(Vertex{1, 2})\n}\n","Hash":"Ogg/+09TFU5IkZ2RcCCZsHf+2fo="}]},{"Title":"结构体字段","Content":"\n  \u003ch2\u003e结构体字段\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    结构体字段使用点号来访问。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"struct-fields.go","Content":"package main\n\nimport \"fmt\"\n\ntype Vertex struct {\n\tX int\n\tY int\n}\n\nfunc main() {\n\tv := Vertex{1, 2}\n\tv.X = 4\n\tfmt.Println(v.X)\n}\n","Hash":"ghPOKvMr3gvwG4M0Z4zg3Bpwgpg="}]},{"Title":"结构体指针","Content":"\n  \u003ch2\u003e结构体指针\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    结构体字段可以通过结构体指针来访问。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    如果我们有一个指向结构体的指针 \u003ccode\u003ep\u003c/code\u003e，那么可以通过 \u003ccode\u003e(*p).X\u003c/code\u003e 来访问其字段 \u003ccode\u003eX\u003c/code\u003e。不过这么写太啰嗦了，所以语言也允许我们使用隐式间接引用，直接写 \u003ccode\u003ep.X\u003c/code\u003e 就可以。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"struct-pointers.go","Content":"package main\n\nimport \"fmt\"\n\ntype Vertex struct {\n\tX int\n\tY int\n}\n\nfunc main() {\n\tv := Vertex{1, 2}\n\tp := \u0026v\n\tp.X = 1e9\n\tfmt.Println(v)\n}\n","Hash":"m85TYBjwWGtTynTtt1+951KkQro="}]},{"Title":"结构体文法","Content":"\n  \u003ch2\u003e结构体文法\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    结构体文法通过直接列出字段的值来新分配一个结构体。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    使用 \u003ccode\u003eName:\u003c/code\u003e 语法可以仅列出部分字段。（字段名的顺序无关。）\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    特殊的前缀 \u003ccode\u003e\u0026amp;\u003c/code\u003e 返回一个指向结构体的指针。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"struct-literals.go","Content":"package main\n\nimport \"fmt\"\n\ntype Vertex struct {\n\tX, Y int\n}\n\nvar (\n\tv1 = Vertex{1, 2}  // has type Vertex\n\tv2 = Vertex{X: 1}  // Y:0 is implicit\n\tv3 = Vertex{}      // X:0 and Y:0\n\tp  = \u0026Vertex{1, 2} // has type *Vertex\n)\n\nfunc main() {\n\tfmt.Println(v1, p, v2, v3)\n}\n","Hash":"EFcXlUPwNHEgPnj9+DjstTj4J+M="}]},{"Title":"数组","Content":"\n  \u003ch2\u003e数组\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    类型 \u003ccode\u003e[n]T\u003c/code\u003e 表示拥有 \u003ccode\u003en\u003c/code\u003e 个 \u003ccode\u003eT\u003c/code\u003e 类型的值的数组。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    表达式\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003evar a [10]int\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    会将变量 \u003ccode\u003ea\u003c/code\u003e 声明为拥有有 10 个整数的数组。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    数组的长度是其类型的一部分，因此数组不能改变大小。这看起来是个限制，不过没关系，Go 提供了更加便利的方式来使用数组。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"array.go","Content":"package main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar a [2]string\n\ta[0] = \"Hello\"\n\ta[1] = \"World\"\n\tfmt.Println(a[0], a[1])\n\tfmt.Println(a)\n\n\tprimes := [6]int{2, 3, 5, 7, 11, 13}\n\tfmt.Println(primes)\n}\n","Hash":"XKucdSMaX+YMKsilkKDJ0Dpqosw="}]},{"Title":"切片","Content":"\n  \u003ch2\u003e切片\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    每个数组的大小都是固定的。而切片则为数组元素提供动态大小的、灵活的视角。在实践中，切片比数组更常用。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    类型 \u003ccode\u003e[]T\u003c/code\u003e 表示一个元素类型为 \u003ccode\u003eT\u003c/code\u003e 的切片。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    切片通过两个下标来界定，即一个上界和一个下界，二者以冒号分隔：\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003ea[low : high]\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    它会选择一个半开区间，包括第一个元素，但排除最后一个元素。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    以下表达式创建了一个切片，它包含 \u003ccode\u003ea\u003c/code\u003e 中下标从 1 到 3 的元素：\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003ea[1:4]\u003c/pre\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"slices.go","Content":"package main\n\nimport \"fmt\"\n\nfunc main() {\n\tprimes := [6]int{2, 3, 5, 7, 11, 13}\n\n\tvar s []int = primes[1:4]\n\tfmt.Println(s)\n}\n","Hash":"tGAAck8epB4KGh6NPwHBhTpmQPM="}]},{"Title":"切片就像数组的引用","Content":"\n  \u003ch2\u003e切片就像数组的引用\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    切片并不存储任何数据，它只是描述了底层数组中的一段。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    更改切片的元素会修改其底层数组中对应的元素。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    与它共享底层数组的切片都会观测到这些修改。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"slices-pointers.go","Content":"package main\n\nimport \"fmt\"\n\nfunc main() {\n\tnames := [4]string{\n\t\t\"John\",\n\t\t\"Paul\",\n\t\t\"George\",\n\t\t\"Ringo\",\n\t}\n\tfmt.Println(names)\n\n\ta := names[0:2]\n\tb := names[1:3]\n\tfmt.Println(a, b)\n\n\tb[0] = \"XXX\"\n\tfmt.Println(a, b)\n\tfmt.Println(names)\n}\n","Hash":"RvHDudRqbwu/hRt7emjDaeWE4CI="}]},{"Title":"切片文法","Content":"\n  \u003ch2\u003e切片文法\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    切片文法类似于没有长度的数组文法。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    这是一个数组文法：\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003e[3]bool{true, true, false}\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    下面这样则会创建一个和上面相同的数组，然后构建一个引用了它的切片：\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003e[]bool{true, true, false}\u003c/pre\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"slice-literals.go","Content":"package main\n\nimport \"fmt\"\n\nfunc main() {\n\tq := []int{2, 3, 5, 7, 11, 13}\n\tfmt.Println(q)\n\n\tr := []bool{true, false, true, true, false, true}\n\tfmt.Println(r)\n\n\ts := []struct {\n\t\ti int\n\t\tb bool\n\t}{\n\t\t{2, true},\n\t\t{3, false},\n\t\t{5, true},\n\t\t{7, true},\n\t\t{11, false},\n\t\t{13, true},\n\t}\n\tfmt.Println(s)\n}\n","Hash":"YuPRaUOZUWgeLJPhkSqy8UltIlU="}]},{"Title":"切片的默认行为","Content":"\n  \u003ch2\u003e切片的默认行为\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    在进行切片时，你可以利用它的默认行为来忽略上下界。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    切片下界的默认值为 \u003ccode\u003e0\u003c/code\u003e，上界则是该切片的长度。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    对于数组\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003evar a [10]int\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    来说，以下切片是等价的：\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003ea[0:10]\na[:10]\na[0:]\na[:]\u003c/pre\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"slice-bounds.go","Content":"package main\n\nimport \"fmt\"\n\nfunc main() {\n\ts := []int{2, 3, 5, 7, 11, 13}\n\n\ts = s[1:4]\n\tfmt.Println(s)\n\n\ts = s[:2]\n\tfmt.Println(s)\n\n\ts = s[1:]\n\tfmt.Println(s)\n}\n","Hash":"126LTJWLpCX7iNszKYg/L7YEZxk="}]},{"Title":"切片的长度与容量","Content":"\n  \u003ch2\u003e切片的长度与容量\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    切片拥有 \u003cb\u003e长度\u003c/b\u003e 和 \u003cb\u003e容量\u003c/b\u003e。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    切片的长度就是它所包含的元素个数。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    切片 \u003ccode\u003es\u003c/code\u003e 的长度和容量可通过表达式 \u003ccode\u003elen(s)\u003c/code\u003e 和 \u003ccode\u003ecap(s)\u003c/code\u003e 来获取。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    你可以通过重新切片来扩展一个切片，给它提供足够的容量。试着修改示例程序中的切片操作，向外扩展它的容量，看看会发生什么。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"slice-len-cap.go","Content":"package main\n\nimport \"fmt\"\n\nfunc main() {\n\ts := []int{2, 3, 5, 7, 11, 13}\n\tprintSlice(s)\n\n\t// Slice the slice to give it zero length.\n\ts = s[:0]\n\tprintSlice(s)\n\n\t// Extend its length.\n\ts = s[:4]\n\tprintSlice(s)\n\n\t// Drop its first two values.\n\ts = s[2:]\n\tprintSlice(s)\n}\n\nfunc printSlice(s []int) {\n\tfmt.Printf(\"len=%d cap=%d %v\\n\", len(s), cap(s), s)\n}\n","Hash":"kCcGGXYSE7FIvqMQhtNwpkn+kEY="}]},{"Title":"nil 切片","Content":"\n  \u003ch2\u003enil 切片\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    切片的零值是 \u003ccode\u003enil\u003c/code\u003e。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    nil 切片的长度和容量为 0 且没有底层数组。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"nil-slices.go","Content":"package main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar s []int\n\tfmt.Println(s, len(s), cap(s))\n\tif s == nil {\n\t\tfmt.Println(\"nil!\")\n\t}\n}\n","Hash":"2gyXCfVBBtLAlqnLlLviWtSEVdA="}]},{"Title":"用 make 创建切片","Content":"\n  \u003ch2\u003e用 make 创建切片\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    切片可以用内建函数 \u003ccode\u003emake\u003c/code\u003e 来创建，这也是你创建动态数组的方式。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ccode\u003emake\u003c/code\u003e 函数会分配一个元素为零值的数组并返回一个引用了它的切片：\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003ea := make([]int, 5)  // len(a)=5\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    要指定它的容量，需向 \u003ccode\u003emake\u003c/code\u003e 传入第三个参数：\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003eb := make([]int, 0, 5) // len(b)=0, cap(b)=5\n\nb = b[:cap(b)] // len(b)=5, cap(b)=5\nb = b[1:]      // len(b)=4, cap(b)=4\u003c/pre\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"making-slices.go","Content":"package main\n\nimport \"fmt\"\n\nfunc main() {\n\ta := make([]int, 5)\n\tprintSlice(\"a\", a)\n\n\tb := make([]int, 0, 5)\n\tprintSlice(\"b\", b)\n\n\tc := b[:2]\n\tprintSlice(\"c\", c)\n\n\td := c[2:5]\n\tprintSlice(\"d\", d)\n}\n\nfunc printSlice(s string, x []int) {\n\tfmt.Printf(\"%s len=%d cap=%d %v\\n\",\n\t\ts, len(x), cap(x), x)\n}\n","Hash":"/jN/up0H3+B/fuCVJtDq/ed1B8w="}]},{"Title":"切片的切片","Content":"\n  \u003ch2\u003e切片的切片\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    切片可包含任何类型，甚至包括其它的切片。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"slices-of-slice.go","Content":"package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc main() {\n\t// Create a tic-tac-toe board.\n\tboard := [][]string{\n\t\t[]string{\"_\", \"_\", \"_\"},\n\t\t[]string{\"_\", \"_\", \"_\"},\n\t\t[]string{\"_\", \"_\", \"_\"},\n\t}\n\n\t// The players take turns.\n\tboard[0][0] = \"X\"\n\tboard[2][2] = \"O\"\n\tboard[1][2] = \"X\"\n\tboard[1][0] = \"O\"\n\tboard[0][2] = \"X\"\n\n\tfor i := 0; i \u003c len(board); i++ {\n\t\tfmt.Printf(\"%s\\n\", strings.Join(board[i], \" \"))\n\t}\n}\n","Hash":"/8SscyOYcdD+cKUcGRMn+bu+z/s="}]},{"Title":"向切片追加元素","Content":"\n  \u003ch2\u003e向切片追加元素\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    为切片追加新的元素是种常用的操作，为此 Go 提供了内建的 \u003ccode\u003eappend\u003c/code\u003e 函数。内建函数的\u003ca href=\"https://go-zh.org/pkg/builtin/#append\" target=\"_blank\"\u003e文档\u003c/a\u003e对此函数有详细的介绍。\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003efunc append(s []T, vs ...T) []T\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ccode\u003eappend\u003c/code\u003e 的第一个参数 \u003ccode\u003es\u003c/code\u003e 是一个元素类型为 \u003ccode\u003eT\u003c/code\u003e 的切片，其余类型为 \u003ccode\u003eT\u003c/code\u003e 的值将会追加到该切片的末尾。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ccode\u003eappend\u003c/code\u003e 的结果是一个包含原切片所有元素加上新添加元素的切片。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    当 \u003ccode\u003es\u003c/code\u003e 的底层数组太小，不足以容纳所有给定的值时，它就会分配一个更大的数组。返回的切片会指向这个新分配的数组。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    （要了解关于切片的更多内容，请阅读文章 \u003ca href=\"https://blog.go-zh.org/go-slices-usage-and-internals\" target=\"_blank\"\u003eGo 切片：用法和本质\u003c/a\u003e。）\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"append.go","Content":"package main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar s []int\n\tprintSlice(s)\n\n\t// append works on nil slices.\n\ts = append(s, 0)\n\tprintSlice(s)\n\n\t// The slice grows as needed.\n\ts = append(s, 1)\n\tprintSlice(s)\n\n\t// We can add more than one element at a time.\n\ts = append(s, 2, 3, 4)\n\tprintSlice(s)\n}\n\nfunc printSlice(s []int) {\n\tfmt.Printf(\"len=%d cap=%d %v\\n\", len(s), cap(s), s)\n}\n","Hash":"L+wfqhUrWgkLDxWCWN4wbYtQYjc="}]},{"Title":"Range","Content":"\n  \u003ch2\u003eRange\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    \u003ccode\u003efor\u003c/code\u003e 循环的 \u003ccode\u003erange\u003c/code\u003e 形式可遍历切片或映射。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    当使用 \u003ccode\u003efor\u003c/code\u003e 循环遍历切片时，每次迭代都会返回两个值。第一个值为当前元素的下标，第二个值为该下标所对应元素的一份副本。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"range.go","Content":"package main\n\nimport \"fmt\"\n\nvar pow = []int{1, 2, 4, 8, 16, 32, 64, 128}\n\nfunc main() {\n\tfor i, v := range pow {\n\t\tfmt.Printf(\"2**%d = %d\\n\", i, v)\n\t}\n}\n","Hash":"TrnpTuf792EXlQom9L3gMkUkz6U="}]},{"Title":"range（续）","Content":"\n  \u003ch2\u003erange（续）\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    可以将下标或值赋予 \u003ccode\u003e_\u003c/code\u003e 来忽略它。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    若你只需要索引，去掉 \u003ccode\u003e, value\u003c/code\u003e 的部分即可。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"range-continued.go","Content":"package main\n\nimport \"fmt\"\n\nfunc main() {\n\tpow := make([]int, 10)\n\tfor i := range pow {\n\t\tpow[i] = 1 \u003c\u003c uint(i) // == 2**i\n\t}\n\tfor _, value := range pow {\n\t\tfmt.Printf(\"%d\\n\", value)\n\t}\n}\n","Hash":"4B84qCi5dJR2qWuL6NhqWoy1TiY="}]},{"Title":"练习：切片","Content":"\n  \u003ch2\u003e练习：切片\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    实现 \u003ccode\u003ePic\u003c/code\u003e。它应当返回一个长度为 \u003ccode\u003edy\u003c/code\u003e 的切片，其中每个元素是一个长度为 \u003ccode\u003edx\u003c/code\u003e，元素类型为 \u003ccode\u003euint8\u003c/code\u003e 的切片。当你运行此程序时，它会将每个整数解释为灰度值（好吧，其实是蓝度值）并显示它所对应的图像。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    图像的选择由你来定。几个有趣的函数包括 \u003ccode\u003e(x+y)/2\u003c/code\u003e, \u003ccode\u003ex*y\u003c/code\u003e, \u003ccode\u003ex^y\u003c/code\u003e, \u003ccode\u003ex*log(y)\u003c/code\u003e 和 \u003ccode\u003ex%(y+1)\u003c/code\u003e。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    （提示：需要使用循环来分配 \u003ccode\u003e[][]uint8\u003c/code\u003e 中的每个 \u003ccode\u003e[]uint8\u003c/code\u003e；请使用 \u003ccode\u003euint8(intValue)\u003c/code\u003e 在类型之间转换；你可能会用到 \u003ccode\u003emath\u003c/code\u003e 包中的函数。）\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"exercise-slices.go","Content":"package main\n\nimport \"golang.org/x/tour/pic\"\n\nfunc Pic(dx, dy int) [][]uint8 {\n}\n\nfunc main() {\n\tpic.Show(Pic)\n}\n","Hash":"kyr5jSqLKV1sQT6BThG9dVbEe8s="}]},{"Title":"映射","Content":"\n  \u003ch2\u003e映射\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    映射将键映射到值。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    映射的零值为 \u003ccode\u003enil\u003c/code\u003e 。\u003ccode\u003enil\u003c/code\u003e 映射既没有键，也不能添加键。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ccode\u003emake\u003c/code\u003e 函数会返回给定类型的映射，并将其初始化备用。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"maps.go","Content":"package main\n\nimport \"fmt\"\n\ntype Vertex struct {\n\tLat, Long float64\n}\n\nvar m map[string]Vertex\n\nfunc main() {\n\tm = make(map[string]Vertex)\n\tm[\"Bell Labs\"] = Vertex{\n\t\t40.68433, -74.39967,\n\t}\n\tfmt.Println(m[\"Bell Labs\"])\n}\n","Hash":"rht5fv2C9kBGGZcCMrdHAdDZMWQ="}]},{"Title":"映射的文法","Content":"\n  \u003ch2\u003e映射的文法\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    映射的文法与结构体相似，不过必须有键名。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"map-literals.go","Content":"package main\n\nimport \"fmt\"\n\ntype Vertex struct {\n\tLat, Long float64\n}\n\nvar m = map[string]Vertex{\n\t\"Bell Labs\": Vertex{\n\t\t40.68433, -74.39967,\n\t},\n\t\"Google\": Vertex{\n\t\t37.42202, -122.08408,\n\t},\n}\n\nfunc main() {\n\tfmt.Println(m)\n}\n","Hash":"rWlZxNfgDt0zX5TH6PVvJJDyQnM="}]},{"Title":"映射的文法（续）","Content":"\n  \u003ch2\u003e映射的文法（续）\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    若顶级类型只是一个类型名，你可以在文法的元素中省略它。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"map-literals-continued.go","Content":"package main\n\nimport \"fmt\"\n\ntype Vertex struct {\n\tLat, Long float64\n}\n\nvar m = map[string]Vertex{\n\t\"Bell Labs\": {40.68433, -74.39967},\n\t\"Google\":    {37.42202, -122.08408},\n}\n\nfunc main() {\n\tfmt.Println(m)\n}\n","Hash":"TfQqduBfdaXr+Lxb7DX9DaIMakg="}]},{"Title":"修改映射","Content":"\n  \u003ch2\u003e修改映射\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    在映射 \u003ccode\u003em\u003c/code\u003e 中插入或修改元素：\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003em[key] = elem\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    获取元素：\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003eelem = m[key]\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    删除元素：\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003edelete(m, key)\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    通过双赋值检测某个键是否存在：\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003eelem, ok = m[key]\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    若 \u003ccode\u003ekey\u003c/code\u003e 在 \u003ccode\u003em\u003c/code\u003e 中，\u003ccode\u003eok\u003c/code\u003e 为 \u003ccode\u003etrue ；否则， ok\u003c/code\u003e 为 \u003ccode\u003efalse\u003c/code\u003e。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    若 \u003ccode\u003ekey\u003c/code\u003e 不在映射中，那么 \u003ccode\u003eelem\u003c/code\u003e 是该映射元素类型的零值。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    同样的，当从 映射 中读取某个不存在的键时，结果是 映射 的元素类型的零值。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003cb\u003e注\u003c/b\u003e ：若 \u003ccode\u003eelem\u003c/code\u003e 或 \u003ccode\u003eok\u003c/code\u003e 还未声明，你可以使用短变量声明：\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003eelem, ok := m[key]\u003c/pre\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"mutating-maps.go","Content":"package main\n\nimport \"fmt\"\n\nfunc main() {\n\tm := make(map[string]int)\n\n\tm[\"Answer\"] = 42\n\tfmt.Println(\"The value:\", m[\"Answer\"])\n\n\tm[\"Answer\"] = 48\n\tfmt.Println(\"The value:\", m[\"Answer\"])\n\n\tdelete(m, \"Answer\")\n\tfmt.Println(\"The value:\", m[\"Answer\"])\n\n\tv, ok := m[\"Answer\"]\n\tfmt.Println(\"The value:\", v, \"Present?\", ok)\n}\n","Hash":"Yb5V377DiiLAd8aCfxxtC0S/sdc="}]},{"Title":"练习：映射","Content":"\n  \u003ch2\u003e练习：映射\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    实现 \u003ccode\u003eWordCount\u003c/code\u003e。它应当返回一个映射，其中包含字符串 \u003ccode\u003es\u003c/code\u003e 中每个“单词”的个数。函数 \u003ccode\u003ewc.Test\u003c/code\u003e 会对此函数执行一系列测试用例，并输出成功还是失败。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    你会发现 \u003ca href=\"https://go-zh.org/pkg/strings/#Fields\" target=\"_blank\"\u003estrings.Fields\u003c/a\u003e 很有帮助。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"exercise-maps.go","Content":"package main\n\nimport (\n\t\"golang.org/x/tour/wc\"\n)\n\nfunc WordCount(s string) map[string]int {\n\treturn map[string]int{\"x\": 1}\n}\n\nfunc main() {\n\twc.Test(WordCount)\n}\n","Hash":"412+IoCx6S2as89oIhOsgqFJUUM="}]},{"Title":"函数值","Content":"\n  \u003ch2\u003e函数值\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    函数也是值。它们可以像其它值一样传递。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    函数值可以用作函数的参数或返回值。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"function-values.go","Content":"package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc compute(fn func(float64, float64) float64) float64 {\n\treturn fn(3, 4)\n}\n\nfunc main() {\n\thypot := func(x, y float64) float64 {\n\t\treturn math.Sqrt(x*x + y*y)\n\t}\n\tfmt.Println(hypot(5, 12))\n\n\tfmt.Println(compute(hypot))\n\tfmt.Println(compute(math.Pow))\n}\n","Hash":"/ZOMEENCqbM+TbJAYLHcNv60gfY="}]},{"Title":"函数的闭包","Content":"\n  \u003ch2\u003e函数的闭包\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    Go 函数可以是一个闭包。闭包是一个函数值，它引用了其函数体之外的变量。该函数可以访问并赋予其引用的变量的值，换句话说，该函数被“绑定”在了这些变量上。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    例如，函数 \u003ccode\u003eadder\u003c/code\u003e 返回一个闭包。每个闭包都被绑定在其各自的 \u003ccode\u003esum\u003c/code\u003e 变量上。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"function-closures.go","Content":"package main\n\nimport \"fmt\"\n\nfunc adder() func(int) int {\n\tsum := 0\n\treturn func(x int) int {\n\t\tsum += x\n\t\treturn sum\n\t}\n}\n\nfunc main() {\n\tpos, neg := adder(), adder()\n\tfor i := 0; i \u003c 10; i++ {\n\t\tfmt.Println(\n\t\t\tpos(i),\n\t\t\tneg(-2*i),\n\t\t)\n\t}\n}\n","Hash":"XQlACZHW1Wkhc0nZnpZGvrVgkWo="}]},{"Title":"练习：斐波纳契闭包","Content":"\n  \u003ch2\u003e练习：斐波纳契闭包\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    让我们用函数做些好玩的事情。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    实现一个 \u003ccode\u003efibonacci\u003c/code\u003e 函数，它返回一个函数（闭包），该闭包返回一个\u003ca href=\"https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97\" target=\"_blank\"\u003e斐波纳契数列\u003c/a\u003e `(0, 1, 1, 2, 3, 5, ...)`。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"exercise-fibonacci-closure.go","Content":"package main\n\nimport \"fmt\"\n\n// fibonacci is a function that returns\n// a function that returns an int.\nfunc fibonacci() func() int {\n}\n\nfunc main() {\n\tf := fibonacci()\n\tfor i := 0; i \u003c 10; i++ {\n\t\tfmt.Println(f())\n\t}\n}\n","Hash":"BQXS8AUg/LPWf2asWqi6FZl1+aU="}]},{"Title":"恭喜！","Content":"\n  \u003ch2\u003e恭喜！\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    你已经完成了本课程！\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    你可以返回\u003ca href=\"/list\" target=\"_self\"\u003e模块列表\u003c/a\u003e看看接下来学习什么，或者继续\u003ca href=\"javascript:click(\u0026#39;.next-page\u0026#39;)\" target=\"_self\"\u003e后面的课程\u003c/a\u003e。\n  \u003c/p\u003e\n  \n\n","Files":[]}]}
,"welcome":{"Title":"欢迎！","Description":"学习使用本指南：包括如何在不同的课程间切换以及运行代码。","Pages":[{"Title":"Hello, 世界","Content":"\n  \u003ch2\u003eHello, 世界\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    欢迎来到 \u003ca href=\"https://go-zh.org/\" target=\"_blank\"\u003eGo 编程语言\u003c/a\u003e指南。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    点击页面左上角的 \u003ca href=\"javascript:highlight(\u0026#34;.logo\u0026#34;)\" target=\"_self\"\u003eGo 指南\u003c/a\u003e可以访问本指南的模块列表。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    你可以随时点击页面右上角的\u003ca href=\"javascript:highlightAndClick(\u0026#34;.nav\u0026#34;)\" target=\"_self\"\u003e菜单\u003c/a\u003e来浏览内容列表。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    本指南由一系列幻灯片贯穿始终，其中有一些练习需要你来完成。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    你可以\n  \u003c/p\u003e\n  \n\n  \u003cul\u003e\n  \n    \u003cli\u003e按\u003ca href=\"javascript:highlight(\u0026#34;.prev-page\u0026#34;)\" target=\"_self\"\u003e\u0026#34;上一页\u0026#34;\u003c/a\u003e 或 \u003ccode\u003ePageUp\u003c/code\u003e 键跳转到上一页，\u003c/li\u003e\n  \n    \u003cli\u003e按\u003ca href=\"javascript:highlight(\u0026#34;.next-page\u0026#34;)\" target=\"_self\"\u003e\u0026#34;下一页\u0026#34;\u003c/a\u003e 或 \u003ccode\u003ePageDown\u003c/code\u003e 键跳转到下一页。\u003c/li\u003e\n  \n  \u003c/ul\u003e\n\n  \n  \u003cp\u003e\n    该指南可以进行交互。点击“\u003ca href=\"javascript:highlightAndClick(\u0026#34;#run\u0026#34;)\" target=\"_self\"\u003e运行\u003c/a\u003e”按钮（或按 \u003ccode\u003eShift+Enter\u003c/code\u003e）可以在\n\n\n    你的电脑上\n\n\n    编译并执行程序。运行结果会显示在代码下面。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    本指南中的示例程序展示了 Go 的各个方面，它们可以成为你积累经验的开始。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    编辑程序并再次执行它。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    注意当你点击\u003ca href=\"javascript:highlightAndClick(\u0026#34;#format\u0026#34;)\" target=\"_self\"\u003e格式化\u003c/a\u003e或按 \u003ccode\u003eCtrl-Enter\u003c/code\u003e 时，编辑器中的文本会被 \u003ca href=\"https://go-zh.org/cmd/gofmt/\" target=\"_blank\"\u003egofmt\u003c/a\u003e 工具格式化。\n\n\n    你可以点击\u003ca href=\"javascript:highlightAndClick(\u0026#34;.syntax-checkbox\u0026#34;)\" target=\"_self\"\u003e语法\u003c/a\u003e开启或关闭语法高亮。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    如果你准备好了，请点击页面底部的\u003ca href=\"javascript:highlightAndClick(\u0026#34;.next-page\u0026#34;)\" target=\"_self\"\u003e右箭头\u003c/a\u003e或按 \u003ccode\u003ePageDown\u003c/code\u003e 键继续。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"hello.go","Content":"package main\n\nimport \"fmt\"\n\nfunc main() {\n\tfmt.Println(\"Hello, 世界\")\n}\n","Hash":"DwfZCJ2NK3FTIJnSUkZkwzma41c="}]},{"Title":"Go 本地化","Content":"\n  \u003ch2\u003eGo 本地化\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    本指南也有其它语言的版本：\n  \u003c/p\u003e\n  \n\n  \u003cul\u003e\n  \n    \u003cli\u003e\u003ca href=\"https://go-tour-br.appspot.com/\" target=\"_blank\"\u003eBrazilian Portuguese — Português do Brasil\u003c/a\u003e\u003c/li\u003e\n  \n    \u003cli\u003e\u003ca href=\"https://go-tour-ca.appspot.com/\" target=\"_blank\"\u003eCatalan — Català\u003c/a\u003e\u003c/li\u003e\n  \n    \u003cli\u003e\u003ca href=\"https://tour.go-zh.org/\" target=\"_blank\"\u003eSimplified Chinese — 中文（简体）\u003c/a\u003e\u003c/li\u003e\n  \n    \u003cli\u003e\u003ca href=\"https://go-tour-zh-tw.appspot.com/\" target=\"_blank\"\u003eTraditional Chinese — 中文（繁體）\u003c/a\u003e\u003c/li\u003e\n  \n    \u003cli\u003e\u003ca href=\"https://go-tour-fr.appspot.com/\" target=\"_blank\"\u003eFrench — Français\u003c/a\u003e\u003c/li\u003e\n  \n    \u003cli\u003e\u003ca href=\"https://go-tour-de.appspot.com/\" target=\"_blank\"\u003eGerman — Deutsch\u003c/a\u003e\u003c/li\u003e\n  \n    \u003cli\u003e\u003ca href=\"https://go-tour-he.appspot.com/\" target=\"_blank\"\u003eHebrew — עִבְרִית\u003c/a\u003e\u003c/li\u003e\n  \n    \u003cli\u003e\u003ca href=\"https://go-tour-id2.appspot.com/\" target=\"_blank\"\u003eIndonesian — Bahasa Indonesia\u003c/a\u003e\u003c/li\u003e\n  \n    \u003cli\u003e\u003ca href=\"https://go-tour-ita.appspot.com/\" target=\"_blank\"\u003eItalian — Italiano\u003c/a\u003e\u003c/li\u003e\n  \n    \u003cli\u003e\u003ca href=\"https://go-tour-jp.appspot.com/\" target=\"_blank\"\u003eJapanese — 日本語\u003c/a\u003e\u003c/li\u003e\n  \n    \u003cli\u003e\u003ca href=\"https://go-tour-kr.appspot.com/\" target=\"_blank\"\u003eKorean — 한국어\u003c/a\u003e\u003c/li\u003e\n  \n    \u003cli\u003e\u003ca href=\"https://go-tour-ro.appspot.com/\" target=\"_blank\"\u003eRomanian — Română\u003c/a\u003e\u003c/li\u003e\n  \n    \u003cli\u003e\u003ca href=\"https://go-tour-ru-ru.appspot.com/\" target=\"_blank\"\u003eRussian - Русский\u003c/a\u003e\u003c/li\u003e\n  \n    \u003cli\u003e\u003ca href=\"https://go-tour-es.appspot.com/\" target=\"_blank\"\u003eSpanish — Español\u003c/a\u003e\u003c/li\u003e\n  \n    \u003cli\u003e\u003ca href=\"https://go-tour-th.appspot.com/\" target=\"_blank\"\u003eThai - ภาษาไทย\u003c/a\u003e\u003c/li\u003e\n  \n    \u003cli\u003e\u003ca href=\"https://go-tour-turkish.appspot.com/\" target=\"_blank\"\u003eTurkish - Türkçe\u003c/a\u003e\u003c/li\u003e\n  \n    \u003cli\u003e\u003ca href=\"https://go-tour-ua.appspot.com/\" target=\"_blank\"\u003eUkrainian — Українська\u003c/a\u003e\u003c/li\u003e\n  \n    \u003cli\u003e\u003ca href=\"https://go-tour-uz.appspot.com/\" target=\"_blank\"\u003eUzbek — Ўзбекча\u003c/a\u003e\u003c/li\u003e\n  \n  \u003c/ul\u003e\n\n  \n  \u003cp\u003e\n    点击\u003ca href=\"javascript:highlightAndClick(\u0026#34;.next-page\u0026#34;)\" target=\"_self\"\u003e“下一页”\u003c/a\u003e按钮或者按 \u003ccode\u003ePageDown\u003c/code\u003e 键继续。\n  \u003c/p\u003e\n  \n\n","Files":[]},{"Title":"恭喜！","Content":"\n  \u003ch2\u003e恭喜！\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    你已经完成了本指南的第一部分！\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    现在点击\u003ca href=\"javascript:highlightAndClick(\u0026#34;.logo\u0026#34;)\" target=\"_self\"\u003e模块\u003c/a\u003e列表看看接下来要学些什么。你也可以继续\u003ca href=\"javascript:click(\u0026#39;.next-page\u0026#39;)\" target=\"_self\"\u003e后面的课程\u003c/a\u003e。\n  \u003c/p\u003e\n  \n\n","Files":[]}]}
,"methods":{"Title":"方法和接口","Description":"本节课包含了方法和接口，可以用这种构造来定义对象及其行为。","Pages":[{"Title":"方法","Content":"\n  \u003ch2\u003e方法\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    Go 没有类。不过你可以为结构体类型定义方法。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    方法就是一类带特殊的 \u003cb\u003e接收者\u003c/b\u003e 参数的函数。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    方法接收者在它自己的参数列表内，位于 \u003ccode\u003efunc\u003c/code\u003e 关键字和方法名之间。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    在此例中，\u003ccode\u003eAbs\u003c/code\u003e 方法拥有一个名为 \u003ccode\u003ev\u003c/code\u003e，类型为 \u003ccode\u003eVertex\u003c/code\u003e 的接收者。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"methods.go","Content":"package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Vertex struct {\n\tX, Y float64\n}\n\nfunc (v Vertex) Abs() float64 {\n\treturn math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n\nfunc main() {\n\tv := Vertex{3, 4}\n\tfmt.Println(v.Abs())\n}\n","Hash":"Ri0Y1X1RvD4ysSICFlAD0YwiciM="}]},{"Title":"方法即函数","Content":"\n  \u003ch2\u003e方法即函数\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    记住：方法只是个带接收者参数的函数。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    现在这个 \u003ccode\u003eAbs\u003c/code\u003e 的写法就是个正常的函数，功能并没有什么变化。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"methods-funcs.go","Content":"package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Vertex struct {\n\tX, Y float64\n}\n\nfunc Abs(v Vertex) float64 {\n\treturn math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n\nfunc main() {\n\tv := Vertex{3, 4}\n\tfmt.Println(Abs(v))\n}\n","Hash":"PKx6hnGY7gFDiHYMaaOuA0NgXYk="}]},{"Title":"方法（续）","Content":"\n  \u003ch2\u003e方法（续）\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    你也可以为非结构体类型声明方法。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    在此例中，我们看到了一个带 \u003ccode\u003eAbs\u003c/code\u003e 方法的数值类型 \u003ccode\u003eMyFloat\u003c/code\u003e。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    你只能为在同一包内定义的类型的接收者声明方法，而不能为其它包内定义的类型（包括 \u003ccode\u003eint\u003c/code\u003e 之类的内建类型）的接收者声明方法。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    （译注：就是接收者的类型定义和方法声明必须在同一包内；不能为内建类型声明方法。）\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"methods-continued.go","Content":"package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype MyFloat float64\n\nfunc (f MyFloat) Abs() float64 {\n\tif f \u003c 0 {\n\t\treturn float64(-f)\n\t}\n\treturn float64(f)\n}\n\nfunc main() {\n\tf := MyFloat(-math.Sqrt2)\n\tfmt.Println(f.Abs())\n}\n","Hash":"gNtDHNEf68ZV05Dn2/JqSHJO/CA="}]},{"Title":"指针接收者","Content":"\n  \u003ch2\u003e指针接收者\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    你可以为指针接收者声明方法。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    这意味着对于某类型 \u003ccode\u003eT\u003c/code\u003e，接收者的类型可以用 \u003ccode\u003e*T\u003c/code\u003e 的文法。（此外，\u003ccode\u003eT\u003c/code\u003e 不能是像 \u003ccode\u003e*int\u003c/code\u003e 这样的指针。）\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    例如，这里为 \u003ccode\u003e*Vertex\u003c/code\u003e 定义了 \u003ccode\u003eScale\u003c/code\u003e 方法。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    指针接收者的方法可以修改接收者指向的值（就像 \u003ccode\u003eScale\u003c/code\u003e 在这做的）。由于方法经常需要修改它的接收者，指针接收者比值接收者更常用。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    试着移除第 16 行 \u003ccode\u003eScale\u003c/code\u003e 函数声明中的 \u003ccode\u003e*\u003c/code\u003e，观察此程序的行为如何变化。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    若使用值接收者，那么 \u003ccode\u003eScale\u003c/code\u003e 方法会对原始 \u003ccode\u003eVertex\u003c/code\u003e 值的副本进行操作。（对于函数的其它参数也是如此。）\u003ccode\u003eScale\u003c/code\u003e 方法必须用指针接受者来更改 \u003ccode\u003emain\u003c/code\u003e 函数中声明的 \u003ccode\u003eVertex\u003c/code\u003e 的值。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"methods-pointers.go","Content":"package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Vertex struct {\n\tX, Y float64\n}\n\nfunc (v Vertex) Abs() float64 {\n\treturn math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n\nfunc (v *Vertex) Scale(f float64) {\n\tv.X = v.X * f\n\tv.Y = v.Y * f\n}\n\nfunc main() {\n\tv := Vertex{3, 4}\n\tv.Scale(10)\n\tfmt.Println(v.Abs())\n}\n","Hash":"fAxvljlTfE3Q8KGvdfBs1fyc8N8="}]},{"Title":"指针与函数","Content":"\n  \u003ch2\u003e指针与函数\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    现在我们要把 \u003ccode\u003eAbs\u003c/code\u003e 和 \u003ccode\u003eScale\u003c/code\u003e 方法重写为函数。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    同样，我们先试着移除掉第 16 的 \u003ccode\u003e*\u003c/code\u003e。你能看出为什么程序的行为改变了吗？要怎样做才能让该示例顺利通过编译？\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    （若你不确定，继续往下看。）\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"methods-pointers-explained.go","Content":"package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Vertex struct {\n\tX, Y float64\n}\n\nfunc Abs(v Vertex) float64 {\n\treturn math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n\nfunc Scale(v *Vertex, f float64) {\n\tv.X = v.X * f\n\tv.Y = v.Y * f\n}\n\nfunc main() {\n\tv := Vertex{3, 4}\n\tScale(\u0026v, 10)\n\tfmt.Println(Abs(v))\n}\n","Hash":"UkaipHI3vU5n36ImMygcCf5cug4="}]},{"Title":"方法与指针重定向","Content":"\n  \u003ch2\u003e方法与指针重定向\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    比较前两个程序，你大概会注意到带指针参数的函数必须接受一个指针：\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003evar v Vertex\nScaleFunc(v, 5)  // 编译错误！\nScaleFunc(\u0026amp;v, 5) // OK\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    而以指针为接收者的方法被调用时，接收者既能为值又能为指针：\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003evar v Vertex\nv.Scale(5)  // OK\np := \u0026amp;v\np.Scale(10) // OK\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    对于语句 \u003ccode\u003ev.Scale(5)\u003c/code\u003e，即便 \u003ccode\u003ev\u003c/code\u003e 是个值而非指针，带指针接收者的方法也能被直接调用。\n\n\n    也就是说，由于 \u003ccode\u003eScale\u003c/code\u003e 方法有一个指针接收者，为方便起见，Go 会将语句 \u003ccode\u003ev.Scale(5)\u003c/code\u003e 解释为 \u003ccode\u003e(\u0026amp;v).Scale(5)\u003c/code\u003e。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"indirection.go","Content":"package main\n\nimport \"fmt\"\n\ntype Vertex struct {\n\tX, Y float64\n}\n\nfunc (v *Vertex) Scale(f float64) {\n\tv.X = v.X * f\n\tv.Y = v.Y * f\n}\n\nfunc ScaleFunc(v *Vertex, f float64) {\n\tv.X = v.X * f\n\tv.Y = v.Y * f\n}\n\nfunc main() {\n\tv := Vertex{3, 4}\n\tv.Scale(2)\n\tScaleFunc(\u0026v, 10)\n\n\tp := \u0026Vertex{4, 3}\n\tp.Scale(3)\n\tScaleFunc(p, 8)\n\n\tfmt.Println(v, p)\n}\n","Hash":"vkdr6283JVw0hF1pb2IlCOpFNks="}]},{"Title":"方法与指针重定向（续）","Content":"\n  \u003ch2\u003e方法与指针重定向（续）\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    同样的事情也发生在相反的方向。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    接受一个值作为参数的函数必须接受一个指定类型的值：\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003evar v Vertex\nfmt.Println(AbsFunc(v))  // OK\nfmt.Println(AbsFunc(\u0026amp;v)) // 编译错误！\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    而以值为接收者的方法被调用时，接收者既能为值又能为指针：\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003evar v Vertex\nfmt.Println(v.Abs()) // OK\np := \u0026amp;v\nfmt.Println(p.Abs()) // OK\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    这种情况下，方法调用 \u003ccode\u003ep.Abs()\u003c/code\u003e 会被解释为 \u003ccode\u003e(*p).Abs()\u003c/code\u003e。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"indirection-values.go","Content":"package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Vertex struct {\n\tX, Y float64\n}\n\nfunc (v Vertex) Abs() float64 {\n\treturn math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n\nfunc AbsFunc(v Vertex) float64 {\n\treturn math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n\nfunc main() {\n\tv := Vertex{3, 4}\n\tfmt.Println(v.Abs())\n\tfmt.Println(AbsFunc(v))\n\n\tp := \u0026Vertex{4, 3}\n\tfmt.Println(p.Abs())\n\tfmt.Println(AbsFunc(*p))\n}\n","Hash":"uUoieKc4jMWBn0pBQ4TNmib2Zlk="}]},{"Title":"选择值或指针作为接收者","Content":"\n  \u003ch2\u003e选择值或指针作为接收者\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    使用指针接收者的原因有二：\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    首先，方法能够修改其接收者指向的值。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    其次，这样可以避免在每次调用方法时复制该值。若值的类型为大型结构体时，这样做会更加高效。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    在本例中，\u003ccode\u003eScale\u003c/code\u003e 和 \u003ccode\u003eAbs\u003c/code\u003e 接收者的类型为 \u003ccode\u003e*Vertex\u003c/code\u003e，即便 \u003ccode\u003eAbs\u003c/code\u003e 并不需要修改其接收者。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    通常来说，所有给定类型的方法都应该有值或指针接收者，但并不应该二者混用。（我们会在接下来几页中明白为什么。）\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"methods-with-pointer-receivers.go","Content":"package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Vertex struct {\n\tX, Y float64\n}\n\nfunc (v *Vertex) Scale(f float64) {\n\tv.X = v.X * f\n\tv.Y = v.Y * f\n}\n\nfunc (v *Vertex) Abs() float64 {\n\treturn math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n\nfunc main() {\n\tv := \u0026Vertex{3, 4}\n\tfmt.Printf(\"Before scaling: %+v, Abs: %v\\n\", v, v.Abs())\n\tv.Scale(5)\n\tfmt.Printf(\"After scaling: %+v, Abs: %v\\n\", v, v.Abs())\n}\n","Hash":"wI65OTRFYWjK10SKGOf4dt++gH8="}]},{"Title":"接口","Content":"\n  \u003ch2\u003e接口\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    \u003cb\u003e接口类型\u003c/b\u003e 是由一组方法签名定义的集合。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    接口类型的值可以保存任何实现了这些方法的值。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003cb\u003e注意：\u003c/b\u003e 示例代码的 22 行存在一个错误。由于 \u003ccode\u003eAbs\u003c/code\u003e 方法只为 \u003ccode\u003e*Vertex\u003c/code\u003e （指针类型）定义，因此 \u003ccode\u003eVertex\u003c/code\u003e（值类型）并未实现 \u003ccode\u003eAbser\u003c/code\u003e。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"interfaces.go","Content":"package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Abser interface {\n\tAbs() float64\n}\n\nfunc main() {\n\tvar a Abser\n\tf := MyFloat(-math.Sqrt2)\n\tv := Vertex{3, 4}\n\n\ta = f  // a MyFloat 实现了 Abser\n\ta = \u0026v // a *Vertex 实现了 Abser\n\n\t// 下面一行，v 是一个 Vertex（而不是 *Vertex）\n\t// 所以没有实现 Abser。\n\ta = v\n\n\tfmt.Println(a.Abs())\n}\n\ntype MyFloat float64\n\nfunc (f MyFloat) Abs() float64 {\n\tif f \u003c 0 {\n\t\treturn float64(-f)\n\t}\n\treturn float64(f)\n}\n\ntype Vertex struct {\n\tX, Y float64\n}\n\nfunc (v *Vertex) Abs() float64 {\n\treturn math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n","Hash":"HnwQ2DAkkaD8GhR3hTIfsDfyQQg="}]},{"Title":"接口与隐式实现","Content":"\n  \u003ch2\u003e接口与隐式实现\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    类型通过实现一个接口的所有方法来实现该接口。既然无需专门显式声明，也就没有“implements”关键字。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    隐式接口从接口的实现中解耦了定义，这样接口的实现可以出现在任何包中，无需提前准备。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    因此，也就无需在每一个实现上增加新的接口名称，这样同时也鼓励了明确的接口定义。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"interfaces-are-satisfied-implicitly.go","Content":"package main\n\nimport \"fmt\"\n\ntype I interface {\n\tM()\n}\n\ntype T struct {\n\tS string\n}\n\n// 此方法表示类型 T 实现了接口 I，但我们无需显式声明此事。\nfunc (t T) M() {\n\tfmt.Println(t.S)\n}\n\nfunc main() {\n\tvar i I = T{\"hello\"}\n\ti.M()\n}\n","Hash":"KUVXSHGJ3M9d9WU64YJ1DCQyWFs="}]},{"Title":"接口值","Content":"\n  \u003ch2\u003e接口值\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    在内部，接口值可以看做包含值和具体类型的元组：\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003e(value, type)\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    接口值保存了一个具体底层类型的具体值。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    接口值调用方法时会执行其底层类型的同名方法。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"interface-values.go","Content":"package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype I interface {\n\tM()\n}\n\ntype T struct {\n\tS string\n}\n\nfunc (t *T) M() {\n\tfmt.Println(t.S)\n}\n\ntype F float64\n\nfunc (f F) M() {\n\tfmt.Println(f)\n}\n\nfunc main() {\n\tvar i I\n\n\ti = \u0026T{\"Hello\"}\n\tdescribe(i)\n\ti.M()\n\n\ti = F(math.Pi)\n\tdescribe(i)\n\ti.M()\n}\n\nfunc describe(i I) {\n\tfmt.Printf(\"(%v, %T)\\n\", i, i)\n}\n","Hash":"eiIEA+Gt4mqHxwJ7UVjixA/Lnic="}]},{"Title":"底层值为 nil 的接口值","Content":"\n  \u003ch2\u003e底层值为 nil 的接口值\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    即便接口内的具体值为 nil，方法仍然会被 nil 接收者调用。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    在一些语言中，这会触发一个空指针异常，但在 Go 中通常会写一些方法来优雅地处理它（如本例中的 \u003ccode\u003eM\u003c/code\u003e 方法）。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003cb\u003e注意：\u003c/b\u003e 保存了 nil 具体值的接口其自身并不为 nil。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"interface-values-with-nil.go","Content":"package main\n\nimport \"fmt\"\n\ntype I interface {\n\tM()\n}\n\ntype T struct {\n\tS string\n}\n\nfunc (t *T) M() {\n\tif t == nil {\n\t\tfmt.Println(\"\u003cnil\u003e\")\n\t\treturn\n\t}\n\tfmt.Println(t.S)\n}\n\nfunc main() {\n\tvar i I\n\n\tvar t *T\n\ti = t\n\tdescribe(i)\n\ti.M()\n\n\ti = \u0026T{\"hello\"}\n\tdescribe(i)\n\ti.M()\n}\n\nfunc describe(i I) {\n\tfmt.Printf(\"(%v, %T)\\n\", i, i)\n}\n","Hash":"d1cP7OS65FGSVmmIKhXhW5Ffn2c="}]},{"Title":"nil 接口值","Content":"\n  \u003ch2\u003enil 接口值\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    nil 接口值既不保存值也不保存具体类型。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    为 nil 接口调用方法会产生运行时错误，因为接口的元组内并未包含能够指明该调用哪个 \u003cb\u003e具体\u003c/b\u003e 方法的类型。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"nil-interface-values.go","Content":"package main\n\nimport \"fmt\"\n\ntype I interface {\n\tM()\n}\n\nfunc main() {\n\tvar i I\n\tdescribe(i)\n\ti.M()\n}\n\nfunc describe(i I) {\n\tfmt.Printf(\"(%v, %T)\\n\", i, i)\n}\n","Hash":"m1jbfiHj+IRAgnXILJjQBJV0WRo="}]},{"Title":"空接口","Content":"\n  \u003ch2\u003e空接口\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    指定了零个方法的接口值被称为 \u003cb\u003e空接口：\u003c/b\u003e\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003einterface{}\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    空接口可保存任何类型的值。（因为每个类型都至少实现了零个方法。）\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    空接口被用来处理未知类型的值。例如，\u003ccode\u003efmt.Print\u003c/code\u003e 可接受类型为 \u003ccode\u003einterface{}\u003c/code\u003e 的任意数量的参数。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"empty-interface.go","Content":"package main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar i interface{}\n\tdescribe(i)\n\n\ti = 42\n\tdescribe(i)\n\n\ti = \"hello\"\n\tdescribe(i)\n}\n\nfunc describe(i interface{}) {\n\tfmt.Printf(\"(%v, %T)\\n\", i, i)\n}\n","Hash":"4kA4LHru7y4jxvYduQKXrxssFu0="}]},{"Title":"类型断言","Content":"\n  \u003ch2\u003e类型断言\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    \u003cb\u003e类型断言\u003c/b\u003e 提供了访问接口值底层具体值的方式。\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003et := i.(T)\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    该语句断言接口值 \u003ccode\u003ei\u003c/code\u003e 保存了具体类型 \u003ccode\u003eT\u003c/code\u003e，并将其底层类型为 \u003ccode\u003eT\u003c/code\u003e 的值赋予变量 \u003ccode\u003et\u003c/code\u003e。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    若 \u003ccode\u003ei\u003c/code\u003e 并未保存 \u003ccode\u003eT\u003c/code\u003e 类型的值，该语句就会触发一个恐慌。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    为了 \u003cb\u003e判断\u003c/b\u003e 一个接口值是否保存了一个特定的类型，类型断言可返回两个值：其底层值以及一个报告断言是否成功的布尔值。\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003et, ok := i.(T)\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    若 \u003ccode\u003ei\u003c/code\u003e 保存了一个 \u003ccode\u003eT\u003c/code\u003e，那么 \u003ccode\u003et\u003c/code\u003e 将会是其底层值，而 \u003ccode\u003eok\u003c/code\u003e 为 \u003ccode\u003etrue\u003c/code\u003e。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    否则，\u003ccode\u003eok\u003c/code\u003e 将为 \u003ccode\u003efalse\u003c/code\u003e 而 \u003ccode\u003et\u003c/code\u003e 将为 \u003ccode\u003eT\u003c/code\u003e 类型的零值，程序并不会产生恐慌。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    请注意这种语法和读取一个映射时的相同之处。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"type-assertions.go","Content":"package main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar i interface{} = \"hello\"\n\n\ts := i.(string)\n\tfmt.Println(s)\n\n\ts, ok := i.(string)\n\tfmt.Println(s, ok)\n\n\tf, ok := i.(float64)\n\tfmt.Println(f, ok)\n\n\tf = i.(float64) // panic\n\tfmt.Println(f)\n}\n","Hash":"pr1VboYZkIF99GtaIO2OF3F1slk="}]},{"Title":"类型选择","Content":"\n  \u003ch2\u003e类型选择\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    \u003cb\u003e类型选择\u003c/b\u003e 是一种按顺序从几个类型断言中选择分支的结构。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    类型选择与一般的 switch 语句相似，不过类型选择中的 case 为类型（而非值），\n\n\n    它们针对给定接口值所存储的值的类型进行比较。\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003eswitch v := i.(type) {\ncase T:\n    // v 的类型为 T\ncase S:\n    // v 的类型为 S\ndefault:\n    // 没有匹配，v 与 i 的类型相同\n}\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    类型选择中的声明与类型断言 \u003ccode\u003ei.(T)\u003c/code\u003e 的语法相同，只是具体类型 \u003ccode\u003eT\u003c/code\u003e 被替换成了关键字 \u003ccode\u003etype\u003c/code\u003e。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    此选择语句判断接口值 \u003ccode\u003ei\u003c/code\u003e 保存的值类型是 \u003ccode\u003eT\u003c/code\u003e 还是 \u003ccode\u003eS\u003c/code\u003e。在 \u003ccode\u003eT\u003c/code\u003e 或 \u003ccode\u003eS\u003c/code\u003e 的情况下，变量 \u003ccode\u003ev\u003c/code\u003e 会分别按 \u003ccode\u003eT\u003c/code\u003e 或 \u003ccode\u003eS\u003c/code\u003e 类型保存 \u003ccode\u003ei\u003c/code\u003e 拥有的值。在默认（即没有匹配）的情况下，变量 \u003ccode\u003ev\u003c/code\u003e 与 \u003ccode\u003ei\u003c/code\u003e 的接口类型和值相同。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"type-switches.go","Content":"package main\n\nimport \"fmt\"\n\nfunc do(i interface{}) {\n\tswitch v := i.(type) {\n\tcase int:\n\t\tfmt.Printf(\"Twice %v is %v\\n\", v, v*2)\n\tcase string:\n\t\tfmt.Printf(\"%q is %v bytes long\\n\", v, len(v))\n\tdefault:\n\t\tfmt.Printf(\"I don't know about type %T!\\n\", v)\n\t}\n}\n\nfunc main() {\n\tdo(21)\n\tdo(\"hello\")\n\tdo(true)\n}\n","Hash":"rCrmEEtXHumb7jgXlgnkuwClmlA="}]},{"Title":"Stringer","Content":"\n  \u003ch2\u003eStringer\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    \u003ca href=\"https://go-zh.org/pkg/fmt/\" target=\"_blank\"\u003e\u003ccode\u003efmt\u003c/code\u003e\u003c/a\u003e 包中定义的 \u003ca href=\"https://go-zh.org/pkg/fmt/#Stringer\" target=\"_blank\"\u003e\u003ccode\u003eStringer\u003c/code\u003e\u003c/a\u003e 是最普遍的接口之一。\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003etype Stringer interface {\n    String() string\n}\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ccode\u003eStringer\u003c/code\u003e 是一个可以用字符串描述自己的类型。\u003ccode\u003efmt\u003c/code\u003e 包（还有很多包）都通过此接口来打印值。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"stringer.go","Content":"package main\n\nimport \"fmt\"\n\ntype Person struct {\n\tName string\n\tAge  int\n}\n\nfunc (p Person) String() string {\n\treturn fmt.Sprintf(\"%v (%v years)\", p.Name, p.Age)\n}\n\nfunc main() {\n\ta := Person{\"Arthur Dent\", 42}\n\tz := Person{\"Zaphod Beeblebrox\", 9001}\n\tfmt.Println(a, z)\n}\n","Hash":"yDPrm3LH5/ruqqZtQwyJqimSgis="}]},{"Title":"练习：Stringer","Content":"\n  \u003ch2\u003e练习：Stringer\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    通过让 \u003ccode\u003eIPAddr\u003c/code\u003e 类型实现 \u003ccode\u003efmt.Stringer\u003c/code\u003e 来打印点号分隔的地址。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    例如，\u003ccode\u003eIPAddr{1, 2, 3, 4}\u003c/code\u003e 应当打印为 \u003ccode\u003e\u0026#34;1.2.3.4\u0026#34;\u003c/code\u003e。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"exercise-stringer.go","Content":"package main\n\nimport \"fmt\"\n\ntype IPAddr [4]byte\n\n// TODO: Add a \"String() string\" method to IPAddr.\n\nfunc main() {\n\thosts := map[string]IPAddr{\n\t\t\"loopback\":  {127, 0, 0, 1},\n\t\t\"googleDNS\": {8, 8, 8, 8},\n\t}\n\tfor name, ip := range hosts {\n\t\tfmt.Printf(\"%v: %v\\n\", name, ip)\n\t}\n}\n","Hash":"6yJwu1CuXiC4ulEVUQfFXVtLSIU="}]},{"Title":"错误","Content":"\n  \u003ch2\u003e错误\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    Go 程序使用 \u003ccode\u003eerror\u003c/code\u003e 值来表示错误状态。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    与 \u003ccode\u003efmt.Stringer\u003c/code\u003e 类似，\u003ccode\u003eerror\u003c/code\u003e 类型是一个内建接口：\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003etype error interface {\n    Error() string\n}\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    （与 \u003ccode\u003efmt.Stringer\u003c/code\u003e 类似，\u003ccode\u003efmt\u003c/code\u003e 包在打印值时也会满足 \u003ccode\u003eerror\u003c/code\u003e。）\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    通常函数会返回一个 \u003ccode\u003eerror\u003c/code\u003e 值，调用的它的代码应当判断这个错误是否等于 \u003ccode\u003enil\u003c/code\u003e 来进行错误处理。\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003ei, err := strconv.Atoi(\u0026#34;42\u0026#34;)\nif err != nil {\n    fmt.Printf(\u0026#34;couldn\u0026#39;t convert number: %v\\n\u0026#34;, err)\n    return\n}\nfmt.Println(\u0026#34;Converted integer:\u0026#34;, i)\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ccode\u003eerror\u003c/code\u003e 为 nil 时表示成功；非 nil 的 \u003ccode\u003eerror\u003c/code\u003e 表示失败。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"errors.go","Content":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\ntype MyError struct {\n\tWhen time.Time\n\tWhat string\n}\n\nfunc (e *MyError) Error() string {\n\treturn fmt.Sprintf(\"at %v, %s\",\n\t\te.When, e.What)\n}\n\nfunc run() error {\n\treturn \u0026MyError{\n\t\ttime.Now(),\n\t\t\"it didn't work\",\n\t}\n}\n\nfunc main() {\n\tif err := run(); err != nil {\n\t\tfmt.Println(err)\n\t}\n}\n","Hash":"L0Wnwx4HpZxHa3I6ymeZsavC3Sc="}]},{"Title":"练习：错误","Content":"\n  \u003ch2\u003e练习：错误\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    从\u003ca href=\"/flowcontrol/8\" target=\"_self\"\u003e之前的练习\u003c/a\u003e中复制 \u003ccode\u003eSqrt\u003c/code\u003e 函数，修改它使其返回 \u003ccode\u003eerror\u003c/code\u003e 值。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ccode\u003eSqrt\u003c/code\u003e 接受到一个负数时，应当返回一个非 nil 的错误值。复数同样也不被支持。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    创建一个新的类型\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003etype ErrNegativeSqrt float64\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    并为其实现\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003efunc (e ErrNegativeSqrt) Error() string\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    方法使其拥有 \u003ccode\u003eerror\u003c/code\u003e 值，通过 \u003ccode\u003eErrNegativeSqrt(-2).Error()\u003c/code\u003e 调用该方法应返回 \u003ccode\u003e\u0026#34;cannot Sqrt negative number: -2\u0026#34;\u003c/code\u003e。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003cb\u003e注意：\u003c/b\u003e 在 \u003ccode\u003eError\u003c/code\u003e 方法内调用 \u003ccode\u003efmt.Sprint(e)\u003c/code\u003e 会让程序陷入死循环。可以通过先转换 \u003ccode\u003ee\u003c/code\u003e 来避免这个问题：\u003ccode\u003efmt.Sprint(float64(e))\u003c/code\u003e。这是为什么呢？\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    修改 \u003ccode\u003eSqrt\u003c/code\u003e 函数，使其接受一个负数时，返回 \u003ccode\u003eErrNegativeSqrt\u003c/code\u003e 值。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"exercise-errors.go","Content":"package main\n\nimport (\n\t\"fmt\"\n)\n\nfunc Sqrt(x float64) (float64, error) {\n\treturn 0, nil\n}\n\nfunc main() {\n\tfmt.Println(Sqrt(2))\n\tfmt.Println(Sqrt(-2))\n}\n","Hash":"EKinkD7zz+EfKluJKZzDvhrrNEE="}]},{"Title":"Reader","Content":"\n  \u003ch2\u003eReader\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    \u003ccode\u003eio\u003c/code\u003e 包指定了 \u003ccode\u003eio.Reader\u003c/code\u003e 接口，它表示从数据流的末尾进行读取。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    Go 标准库包含了该接口的\u003ca href=\"https://go-zh.org/search?q=Read#Global\" target=\"_blank\"\u003e许多实现\u003c/a\u003e，包括文件、网络连接、压缩和加密等等。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ccode\u003eio.Reader\u003c/code\u003e 接口有一个 \u003ccode\u003eRead\u003c/code\u003e 方法：\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003efunc (T) Read(b []byte) (n int, err error)\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ccode\u003eRead\u003c/code\u003e 用数据填充给定的字节切片并返回填充的字节数和错误值。在遇到数据流的结尾时，它会返回一个 \u003ccode\u003eio.EOF\u003c/code\u003e 错误。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    示例代码创建了一个 \u003ca href=\"https://go-zh.org/pkg/strings/#Reader\" target=\"_blank\"\u003e\u003ccode\u003estrings.Reader\u003c/code\u003e\u003c/a\u003e 并以每次 8 字节的速度读取它的输出。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"reader.go","Content":"package main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"strings\"\n)\n\nfunc main() {\n\tr := strings.NewReader(\"Hello, Reader!\")\n\n\tb := make([]byte, 8)\n\tfor {\n\t\tn, err := r.Read(b)\n\t\tfmt.Printf(\"n = %v err = %v b = %v\\n\", n, err, b)\n\t\tfmt.Printf(\"b[:n] = %q\\n\", b[:n])\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t}\n}\n","Hash":"RqUBLmjOXf3/eBY7ah885QcwgNY="}]},{"Title":"练习：Reader","Content":"\n  \u003ch2\u003e练习：Reader\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    实现一个 \u003ccode\u003eReader\u003c/code\u003e 类型，它产生一个 ASCII 字符 \u003ccode\u003e\u0026#39;A\u0026#39;\u003c/code\u003e 的无限流。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"exercise-reader.go","Content":"package main\n\nimport \"golang.org/x/tour/reader\"\n\ntype MyReader struct{}\n\n// TODO: Add a Read([]byte) (int, error) method to MyReader.\n\nfunc main() {\n\treader.Validate(MyReader{})\n}\n","Hash":"6sW4PjGtNz4iki66R8mgRBai0h8="}]},{"Title":"练习：rot13Reader","Content":"\n  \u003ch2\u003e练习：rot13Reader\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    有种常见的模式是一个 \u003ca href=\"https://go-zh.org/pkg/io/#Reader\" target=\"_blank\"\u003e\u003ccode\u003eio.Reader\u003c/code\u003e\u003c/a\u003e 包装另一个 \u003ccode\u003eio.Reader\u003c/code\u003e，然后通过某种方式修改其数据流。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    例如，\u003ca href=\"https://go-zh.org/pkg/compress/gzip/#NewReader\" target=\"_blank\"\u003e\u003ccode\u003egzip.NewReader\u003c/code\u003e\u003c/a\u003e 函数接受一个 \u003ccode\u003eio.Reader\u003c/code\u003e（已压缩的数据流）并返回一个同样实现了 \u003ccode\u003eio.Reader\u003c/code\u003e 的 \u003ccode\u003e*gzip.Reader\u003c/code\u003e（解压后的数据流）。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    编写一个实现了 \u003ccode\u003eio.Reader\u003c/code\u003e 并从另一个 \u003ccode\u003eio.Reader\u003c/code\u003e 中读取数据的 \u003ccode\u003erot13Reader\u003c/code\u003e，通过应用 \u003ca href=\"http://en.wikipedia.org/wiki/ROT13\" target=\"_blank\"\u003erot13\u003c/a\u003e 代换密码对数据流进行修改。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ccode\u003erot13Reader\u003c/code\u003e 类型已经提供。实现 \u003ccode\u003eRead\u003c/code\u003e 方法以满足 \u003ccode\u003eio.Reader\u003c/code\u003e。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"exercise-rot-reader.go","Content":"package main\n\nimport (\n\t\"io\"\n\t\"os\"\n\t\"strings\"\n)\n\ntype rot13Reader struct {\n\tr io.Reader\n}\n\nfunc main() {\n\ts := strings.NewReader(\"Lbh penpxrq gur pbqr!\")\n\tr := rot13Reader{s}\n\tio.Copy(os.Stdout, \u0026r)\n}\n","Hash":"XPnNEi79ZGAvQXBKmWMSdJasF8g="}]},{"Title":"图像","Content":"\n  \u003ch2\u003e图像\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    \u003ca href=\"https://go-zh.org/pkg/image/#Image\" target=\"_blank\"\u003e\u003ccode\u003eimage\u003c/code\u003e\u003c/a\u003e 包定义了 \u003ccode\u003eImage\u003c/code\u003e 接口：\n  \u003c/p\u003e\n  \n\n  \n  \u003cpre\u003epackage image\n\ntype Image interface {\n    ColorModel() color.Model\n    Bounds() Rectangle\n    At(x, y int) color.Color\n}\u003c/pre\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003cb\u003e注意：\u003c/b\u003e \u003ccode\u003eBounds\u003c/code\u003e 方法的返回值 \u003ccode\u003eRectangle\u003c/code\u003e 实际上是一个 \u003ca href=\"https://go-zh.org/pkg/image/#Rectangle\" target=\"_blank\"\u003e\u003ccode\u003eimage.Rectangle\u003c/code\u003e\u003c/a\u003e，它在 \u003ccode\u003eimage\u003c/code\u003e 包中声明。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    （请参阅\u003ca href=\"https://go-zh.org/pkg/image/#Image\" target=\"_blank\"\u003e文档\u003c/a\u003e了解全部信息。）\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ccode\u003ecolor.Color\u003c/code\u003e 和 \u003ccode\u003ecolor.Model\u003c/code\u003e 类型也是接口，但是通常因为直接使用预定义的实现 \u003ccode\u003eimage.RGBA\u003c/code\u003e 和 \u003ccode\u003eimage.RGBAModel\u003c/code\u003e 而被忽视了。这些接口和类型由 \u003ca href=\"https://go-zh.org/pkg/image/color/\" target=\"_blank\"\u003e\u003ccode\u003eimage/color\u003c/code\u003e\u003c/a\u003e 包定义。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"images.go","Content":"package main\n\nimport (\n\t\"fmt\"\n\t\"image\"\n)\n\nfunc main() {\n\tm := image.NewRGBA(image.Rect(0, 0, 100, 100))\n\tfmt.Println(m.Bounds())\n\tfmt.Println(m.At(0, 0).RGBA())\n}\n","Hash":"V0zUjPfdo4VBN4QyphuqbhHFKR8="}]},{"Title":"练习：图像","Content":"\n  \u003ch2\u003e练习：图像\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    还记得之前编写的图片生成器吗？我们再来编写另外一个，不过这次它将会返回一个 \u003ccode\u003eimage.Image\u003c/code\u003e 的实现而非一个数据切片。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    定义你自己的 \u003ccode\u003eImage\u003c/code\u003e 类型，实现\u003ca href=\"https://go-zh.org/pkg/image/#Image\" target=\"_blank\"\u003e必要的方法\u003c/a\u003e并调用 \u003ccode\u003epic.ShowImage\u003c/code\u003e。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ccode\u003eBounds\u003c/code\u003e 应当返回一个 \u003ccode\u003eimage.Rectangle\u003c/code\u003e ，例如 \u003ccode\u003eimage.Rect(0, 0, w, h)\u003c/code\u003e。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ccode\u003eColorModel\u003c/code\u003e 应当返回 \u003ccode\u003ecolor.RGBAModel\u003c/code\u003e。\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    \u003ccode\u003eAt\u003c/code\u003e 应当返回一个颜色。上一个图片生成器的值 \u003ccode\u003ev\u003c/code\u003e 对应于此次的 \u003ccode\u003ecolor.RGBA{v, v, 255, 255}\u003c/code\u003e。\n  \u003c/p\u003e\n  \n\n\t\n\t\t\n\t\n\n","Files":[{"Name":"exercise-images.go","Content":"package main\n\nimport \"golang.org/x/tour/pic\"\n\ntype Image struct{}\n\nfunc main() {\n\tm := Image{}\n\tpic.ShowImage(m)\n}\n","Hash":"Dwmfm74h39vycGjq0+RRDHA66CM="}]},{"Title":"恭喜！","Content":"\n  \u003ch2\u003e恭喜！\u003c/h2\u003e\n  \n  \n  \u003cp\u003e\n    你已经完成了本课程！\n  \u003c/p\u003e\n  \n\n  \n  \u003cp\u003e\n    你可以返回\u003ca href=\"/list\" target=\"_self\"\u003e模块\u003c/a\u003e列表看看接下来学习什么，或者继续\u003ca href=\"javascript:click(\u0026#39;.next-page\u0026#39;)\" target=\"_self\"\u003e后面的课程\u003c/a\u003e。\n  \u003c/p\u003e\n  \n\n","Files":[]}]}
}